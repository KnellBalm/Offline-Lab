[
  {
    "problem_id": "saas_sql_001_set1",
    "difficulty": "easy",
    "topic": "activation",
    "requester": "그로스팀",
    "question": "그로스팀입니다. 신규 사용자가 온보딩을 완료하고 실제로 프로덕트를 사용하기 시작하는 시점을 파악하고 싶습니다. 'onboarding_complete' 이벤트 이후 3일 이내에 'feature_use' 이벤트가 3회 이상 발생하는 사용자들의 'onboarding_complete' 이벤트 시간을 기준으로, 총 몇 명의 사용자가 Activation 단계에 도달했는지 알려주세요. 결과는 'onboarding_complete' 시간 순으로 정렬해주세요.",
    "context": "Activation은 우리 SaaS의 핵심 성장 동력입니다. 신규 사용자가 온보딩을 성공적으로 마치고 프로덕트의 가치를 인지하여 활발하게 사용하기 시작하는 임계점을 정의하고 측정하는 것이 중요합니다. 이 데이터를 통해 온보딩 프로세스의 효과성을 파악하고 개선점을 찾을 수 있습니다.",
    "submission_requirements": "결과는 'onboarding_complete_time' 컬럼을 기준으로 오름차순 정렬해주세요. 'activation_users_count' 컬럼으로 총 Activation 사용자 수를 제시해주세요.",
    "answer_sql": "WITH onboarding_completed AS (\n    SELECT\n        user_id,\n        event_time AS onboarding_complete_time\n    FROM\n        pa_events\n    WHERE\n        event_name = 'onboarding_complete'\n),\nfirst_feature_use AS (\n    SELECT\n        user_id,\n        MIN(event_time) AS first_feature_use_time\n    FROM\n        pa_events\n    WHERE\n        event_name = 'feature_use'\n    GROUP BY\n        user_id\n),\nactivated_users AS (\n    SELECT\n        oc.user_id,\n        oc.onboarding_complete_time\n    FROM\n        onboarding_completed oc\n    JOIN\n        first_feature_use ffu ON oc.user_id = ffu.user_id\n    WHERE\n        ffu.first_feature_use_time >= oc.onboarding_complete_time\n        AND ffu.first_feature_use_time < oc.onboarding_complete_time + INTERVAL '3 days'\n    GROUP BY\n        oc.user_id,\n        oc.onboarding_complete_time\n    HAVING\n        COUNT(CASE WHEN event_name = 'feature_use' THEN 1 END) >= 3\n)\nSELECT\n    COUNT(DISTINCT user_id) AS activation_users_count\nFROM\n    activated_users;",
    "expected_description": "온보딩 완료 후 3일 이내에 3회 이상의 'feature_use' 이벤트를 발생시킨 총 사용자 수",
    "expected_columns": [
      "activation_users_count"
    ],
    "sort_keys": [
      "onboarding_complete_time"
    ],
    "hint": "'onboarding_complete' 이벤트와 'feature_use' 이벤트 시간을 비교하고, 두 이벤트 간의 간격을 계산해야 합니다. CTE(Common Table Expression)를 활용하여 단계를 나누면 쿼리가 더 명확해집니다.",
    "xp_value": 3,
    "expected_meta": {
      "error": "column \"event_name\" does not exist\nLINE 36:         COUNT(CASE WHEN event_name = 'feature_use' THEN 1 EN...\n                                 ^\n"
    }
  },
  {
    "problem_id": "saas_sql_002_set1",
    "difficulty": "easy",
    "topic": "engagement",
    "requester": "PM팀",
    "question": "PM팀입니다. 최근 1달 동안(2025-11-26 ~ 2025-12-26) 가장 많이 사용된 상위 5개 'feature_use' 이벤트별로 몇 명의 사용자가 해당 기능을 사용했는지 집계해주세요. 결과는 사용자 수 기준으로 내림차순 정렬해주세요.",
    "context": "어떤 기능이 사용자들에게 가장 인기가 있는지 파악하는 것은 기능 개발 우선순위를 정하고 성공적인 기능을 더 많은 사용자에게 확산시키는 데 중요합니다. 'feature_use' 이벤트의 상세 내용을 분석하여 사용자 참여도가 높은 기능을 식별합니다.",
    "submission_requirements": "결과는 'user_count' 기준으로 내림차순 정렬하고, 상위 5개 행만 보여주세요. 'event_name'과 'user_count' 컬럼을 포함해야 합니다.",
    "answer_sql": "SELECT\n    event_name,\n    COUNT(DISTINCT user_id) AS user_count\nFROM\n    pa_events\nWHERE\n    event_name = 'feature_use'\n    AND event_time BETWEEN '2025-11-26 00:00:00' AND '2025-12-26 23:59:59'\nGROUP BY\n    event_name\nORDER BY\n    user_count DESC\nLIMIT 5;",
    "expected_description": "최근 1달간 'feature_use' 이벤트별 고유 사용자 수 (상위 5개)",
    "expected_columns": [
      "event_name",
      "user_count"
    ],
    "sort_keys": [
      "user_count DESC"
    ],
    "hint": "특정 기간 동안 'feature_use' 이벤트를 발생시킨 고유 사용자 수를 세기 위해 COUNT(DISTINCT user_id)를 사용합니다.",
    "xp_value": 3,
    "expected_meta": {
      "row_count": 1,
      "columns": [
        {
          "name": "event_name",
          "type": "text"
        },
        {
          "name": "user_count",
          "type": "bigint"
        }
      ],
      "grading_table": "grading.expected_saas_sql_002_set1"
    }
  },
  {
    "problem_id": "saas_sql_003_set1",
    "difficulty": "medium",
    "topic": "activation",
    "requester": "그로스팀",
    "question": "그로스팀입니다. 신규 가입자(2025-11-01 이후 가입)들의 'onboarding_complete' 이벤트 발생까지 평균 몇 일이 걸리는지 계산해주세요. 'onboarding_complete' 이벤트가 발생하지 않은 사용자는 분석에서 제외해주세요. 결과는 'average_days_to_onboarding'으로 표시해주세요.",
    "context": "신규 사용자가 온보딩을 완료하는 데 걸리는 시간은 프로덕트의 초기 사용성 및 학습 곡선과 관련이 있습니다. 평균 온보딩 완료 시간을 파악하여 온보딩 프로세스의 병목 구간을 식별하고 개선 전략을 수립할 수 있습니다.",
    "submission_requirements": "결과는 'average_days_to_onboarding' 컬럼으로 제시해주세요. 소수점 둘째 자리까지 반올림해주세요.",
    "answer_sql": "SELECT\n    ROUND(AVG(EXTRACT(EPOCH FROM (e.event_time - u.signup_at)) / 86400.0), 2) AS average_days_to_onboarding\nFROM\n    pa_users u\nJOIN\n    pa_events e ON u.user_id = e.user_id\nWHERE\n    u.signup_at >= '2025-11-01 00:00:00'\n    AND e.event_name = 'onboarding_complete';",
    "expected_description": "신규 가입자 중 온보딩을 완료한 사용자들이 가입 후 온보딩 완료까지 걸린 평균 일수",
    "expected_columns": [
      "average_days_to_onboarding"
    ],
    "sort_keys": [],
    "hint": "날짜 차이를 계산하기 위해 EXTRACT 함수와 EPOCH를 활용하고, 일 단위로 변환합니다. 가입일과 'onboarding_complete' 이벤트 시간을 비교합니다.",
    "xp_value": 5,
    "expected_meta": {
      "row_count": 1,
      "columns": [
        {
          "name": "average_days_to_onboarding",
          "type": "numeric"
        }
      ],
      "grading_table": "grading.expected_saas_sql_003_set1"
    }
  },
  {
    "problem_id": "saas_sql_004_set1",
    "difficulty": "medium",
    "topic": "engagement",
    "requester": "PM팀",
    "question": "PM팀입니다. 2025년 11월 동안 'create_project' 이벤트를 1회 이상 발생시킨 사용자 중, 'invite_member' 이벤트도 1회 이상 발생시킨 사용자의 비율을 계산해주세요. 이 비율은 'collaboration_adoption_rate'로 표시해주세요. 결과는 소수점 넷째 자리까지 반올림해주세요.",
    "context": "협업 기능의 활성화 정도는 SaaS 플랫폼의 네트워크 효과 및 사용자 간 상호작용을 이해하는 데 중요합니다. 'create_project'는 기본적인 기능 사용을, 'invite_member'는 팀원과의 협업을 의미하므로, 두 기능의 연관성을 분석하여 협업 기능 도입률을 측정합니다.",
    "submission_requirements": "결과는 'collaboration_adoption_rate' 컬럼으로 제시해주세요. 소수점 넷째 자리까지 반올림해주세요. 결과는 0.0000 ~ 1.0000 형태여야 합니다.",
    "answer_sql": "WITH users_creating_projects AS (\n    SELECT DISTINCT user_id\n    FROM pa_events\n    WHERE event_name = 'create_project'\n      AND event_time BETWEEN '2025-11-01 00:00:00' AND '2025-11-30 23:59:59'\n),\nusers_inviting_members AS (\n    SELECT DISTINCT user_id\n    FROM pa_events\n    WHERE event_name = 'invite_member'\n      AND event_time BETWEEN '2025-11-01 00:00:00' AND '2025-11-30 23:59:59'\n),\ncollaborative_users AS (\n    SELECT DISTINCT ucp.user_id\n    FROM users_creating_projects ucp\n    JOIN users_inviting_members uim ON ucp.user_id = uim.user_id\n)\nSELECT\n    ROUND(CAST(COUNT(cu.user_id) AS NUMERIC) / COUNT(DISTINCT ucp_all.user_id), 4) AS collaboration_adoption_rate\nFROM\n    users_creating_projects ucp_all\nLEFT JOIN\n    collaborative_users cu ON ucp_all.user_id = cu.user_id;",
    "expected_description": "2025년 11월, 프로젝트를 생성한 사용자 중 멤버를 초대한 사용자 비율",
    "expected_columns": [
      "collaboration_adoption_rate"
    ],
    "sort_keys": [],
    "hint": "두 가지 기준(create_project, invite_member)을 만족하는 사용자 집단을 구하고, 전체 'create_project' 사용자 대비 비율을 계산합니다. JOIN과 COUNT(DISTINCT)를 활용하세요.",
    "xp_value": 5,
    "expected_meta": {
      "row_count": 1,
      "columns": [
        {
          "name": "collaboration_adoption_rate",
          "type": "numeric"
        }
      ],
      "grading_table": "grading.expected_saas_sql_004_set1"
    }
  },
  {
    "problem_id": "saas_sql_005_set1",
    "difficulty": "hard",
    "topic": "churn",
    "requester": "CS팀",
    "question": "CS팀입니다. 'cancel_subscription' 이벤트가 발생하기 7일 이내에 발생한 사용자들의 이벤트 종류별 횟수를 분석하여, Churn 위험 고객의 행동 패턴을 파악하고 싶습니다. 2025년 12월에 'cancel_subscription' 이벤트를 발생시킨 사용자들의 'cancel_subscription' 이벤트 발생 직전 7일간의 모든 이벤트(event_name)별 발생 횟수를 집계해주세요. 결과는 사용자 ID, 이벤트 이름, 그리고 해당 이벤트의 총 횟수를 보여주세요. 사용자 ID와 이벤트 이름 순으로 정렬해주세요.",
    "context": "고객 이탈(Churn)은 SaaS 비즈니스에 치명적입니다. 이탈 직전 고객들의 행동 패턴을 분석하여 이탈 징후를 미리 포착하고 선제적인 대응을 할 수 있습니다. 'cancel_subscription' 이전의 활동을 깊이 있게 분석하여 이탈 예측 모델 개발에 활용하고자 합니다.",
    "submission_requirements": "결과는 user_id, event_name, event_count 컬럼을 포함해야 합니다. user_id와 event_name 기준으로 오름차순 정렬해주세요.",
    "answer_sql": "WITH cancel_users AS (\n    SELECT\n        user_id,\n        event_time AS cancel_time\n    FROM\n        pa_events\n    WHERE\n        event_name = 'cancel_subscription'\n        AND event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n),\npre_churn_events AS (\n    SELECT\n        pe.user_id,\n        pe.event_name,\n        COUNT(pe.event_id) AS event_count\n    FROM\n        pa_events pe\n    JOIN\n        cancel_users cu ON pe.user_id = cu.user_id\n    WHERE\n        pe.event_time >= cu.cancel_time - INTERVAL '7 days'\n        AND pe.event_time < cu.cancel_time\n    GROUP BY\n        pe.user_id,\n        pe.event_name\n)\nSELECT\n    user_id,\n    event_name,\n    event_count\nFROM\n    pre_churn_events\nORDER BY\n    user_id ASC,\n    event_name ASC;",
    "expected_description": "2025년 12월 구독 취소 사용자들의, 구독 취소 7일 전부터 구독 취소 시점까지 발생한 모든 이벤트 종류별 횟수",
    "expected_columns": [
      "user_id",
      "event_name",
      "event_count"
    ],
    "sort_keys": [
      "user_id ASC",
      "event_name ASC"
    ],
    "hint": "먼저 구독 취소 사용자 목록을 추출합니다. 그 후, 각 사용자의 구독 취소 시간을 기준으로 이전 7일 동안 발생한 이벤트를 필터링하고 집계합니다. `INTERVAL` 연산자를 사용하여 날짜 범위를 지정하는 것이 중요합니다.",
    "xp_value": 8,
    "expected_meta": {
      "row_count": 1991,
      "columns": [
        {
          "name": "user_id",
          "type": "text"
        },
        {
          "name": "event_name",
          "type": "text"
        },
        {
          "name": "event_count",
          "type": "bigint"
        }
      ],
      "grading_table": "grading.expected_saas_sql_005_set1"
    }
  },
  {
    "problem_id": "saas_sql_006_set1",
    "difficulty": "hard",
    "topic": "revenue",
    "requester": "세일즈팀",
    "question": "세일즈팀입니다. 'upgrade_plan' 이벤트 발생 전에 'feature_use' 이벤트를 5회 이상 기록한 사용자의 'upgrade_plan' 이벤트 발생 비율을 분석하여, 유료 전환 가능성이 높은 사용자 그룹을 파악하고 싶습니다. 2025년 11월 1일부터 2025년 12월 26일 사이에 'upgrade_plan' 이벤트를 발생시킨 사용자 중, 'upgrade_plan' 이벤트 발생 전 마지막 세션에서 'feature_use' 이벤트를 5회 이상 사용한 사용자의 비율을 계산해주세요. 결과는 'upgrade_potential_rate'로 표시해주세요. 소수점 넷째 자리까지 반올림해주세요.",
    "context": "유료 전환 가능성이 높은 사용자를 식별하는 것은 영업 및 마케팅 활동의 효율성을 높이는 데 매우 중요합니다. 'feature_use'를 집중적으로 사용하는 것은 프로덕트의 가치를 인지하고 있음을 나타내므로, 이러한 사용자들의 업그레이드 전환율을 측정하여 인사이트를 얻고자 합니다.",
    "submission_requirements": "결과는 'upgrade_potential_rate' 컬럼으로 제시해주세요. 소수점 넷째 자리까지 반올림해주세요. 결과는 0.0000 ~ 1.0000 형태여야 합니다. NULL 값은 0으로 처리해주세요.",
    "answer_sql": "WITH upgraded_users AS (\n    SELECT\n        user_id,\n        order_id, -- Assuming order_id is present for upgraded users if orders table had data\n        order_time AS upgrade_time\n    FROM\n        pa_orders\n    WHERE order_time BETWEEN '2025-11-01 00:00:00' AND '2025-12-26 23:59:59'\n    -- If pa_orders is empty, we need to infer upgrade based on event, which is not ideal\n    -- Assuming 'upgrade_plan' event signifies an upgrade for this problem context\n    -- In a real scenario, pa_orders would be used.\n),\nusers_with_recent_feature_use AS (\n    SELECT\n        e.user_id,\n        e.session_id,\n        COUNT(e.event_id) AS feature_use_count_in_session\n    FROM\n        pa_events e\n    JOIN\n        upgraded_users uu ON e.user_id = uu.user_id\n    WHERE\n        e.event_name = 'feature_use'\n        AND e.event_time BETWEEN uu.upgrade_time - INTERVAL '1 day' AND uu.upgrade_time\n    GROUP BY\n        e.user_id,\n        e.session_id\n    HAVING\n        COUNT(e.event_id) >= 5\n),\nusers_who_upgraded_with_potential AS (\n    SELECT DISTINCT\n        uu.user_id\n    FROM\n        upgraded_users uu\n    JOIN\n        users_with_recent_feature_use uwf ON uu.user_id = uwf.user_id\n)\nSELECT\n    ROUND(\n        COALESCE(CAST(COUNT(DISTINCT uwf.user_id) AS NUMERIC), 0) / \n        NULLIF(CAST(COUNT(DISTINCT uu.user_id) AS NUMERIC), 0),\n    4) AS upgrade_potential_rate\nFROM\n    upgraded_users uu\nLEFT JOIN\n    users_who_upgraded_with_potential uwf ON uu.user_id = uwf.user_id;",
    "expected_description": "2025년 11월 1일부터 2025년 12월 26일 사이 업그레이드한 사용자 중, 업그레이드 직전 1일 동안 세션당 'feature_use' 이벤트 5회 이상을 사용한 사용자의 비율",
    "expected_columns": [
      "upgrade_potential_rate"
    ],
    "sort_keys": [],
    "hint": "'upgrade_plan' 이벤트 발생 시점 직전 1일 동안 'feature_use' 이벤트를 5회 이상 사용한 세션을 식별해야 합니다. `pa_orders` 테이블이 비어있으므로, `pa_events` 테이블의 'upgrade_plan' 이벤트를 업그레이드로 간주하여 분석을 진행합니다. (실제 업무에서는 `pa_orders` 테이블의 존재 여부와 데이터 유무를 먼저 확인해야 합니다.) NULLIF와 COALESCE를 사용하여 Division by Zero 오류를 방지하고, 최종 비율 계산 시 0으로 처리합니다.",
    "xp_value": 8,
    "expected_meta": {
      "row_count": 1,
      "columns": [
        {
          "name": "upgrade_potential_rate",
          "type": "numeric"
        }
      ],
      "grading_table": "grading.expected_saas_sql_006_set1"
    }
  }
]
[
  {
    "problem_id": "2026-01-01_commerce_sql_001_set1",
    "difficulty": "easy",
    "topic": "revenue",
    "requester": "경영진",
    "question": "안녕하세요, 경영진입니다. 지난 12월 한 달간의 총 GMV(Gross Merchandise Value)와 평균 주문 금액(AOV) 추이를 일별로 파악하고 싶습니다. 각 날짜별로 GMV와 AOV를 계산하여, 총 매출 기여도를 파악하고 싶습니다. 결과는 날짜별 오름차순으로 정렬해주세요.",
    "context": "월말 보고를 위해 최근 한 달간의 핵심 매출 지표 변화를 빠르게 파악하는 것이 중요합니다. 특히 일별 GMV와 AOV를 통해 어떤 날짜에 매출이 집중되었는지, 또는 특정 이벤트(예: 프로모션)의 효과를 측정하는 데 도움이 될 것입니다.",
    "submission_requirements": "결과는 date 컬럼 기준 오름차순 정렬. GMV는 정수, AOV는 소수점 둘째 자리까지 반올림하여 표시합니다.",
    "answer_sql": "WITH daily_orders AS (\n    SELECT\n        DATE(order_time) AS order_date,\n        SUM(amount) AS daily_gmv,\n        AVG(amount) AS daily_aov\n    FROM\n        pa_orders\n    WHERE\n        order_time >= '2025-12-01 00:00:00'\n        AND order_time < '2026-01-01 00:00:00'\n    GROUP BY\n        DATE(order_time)\n)\nSELECT\n    order_date,\n    daily_gmv,\n    ROUND(daily_aov, 2) AS daily_aov\nFROM\n    daily_orders\nORDER BY\n    order_date ASC;",
    "expected_description": "날짜별 총 판매 금액(GMV)과 해당 날짜의 평균 주문 금액(AOV)을 보여줍니다.",
    "expected_columns": [
      "order_date",
      "daily_gmv",
      "daily_aov"
    ],
    "sort_keys": [
      "order_date"
    ],
    "hint": "pa_orders 테이블의 order_time을 DATE 함수로 추출하여 그룹화하고, SUM과 AVG 함수를 사용하여 각각 GMV와 AOV를 계산합니다. 날짜 범위 조건은 12월 한 달로 설정합니다.",
    "date": "2026-01-01",
    "set_index": 1,
    "xp_value": 3,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_commerce_sql_002_set1",
    "difficulty": "easy",
    "topic": "activation",
    "requester": "PM팀",
    "question": "안녕하세요, PM팀입니다. 저희 플랫폼의 첫 구매 전환율을 파악하고 싶습니다. 'purchase' 이벤트를 처음으로 발생시킨 사용자들의 총 수를 알고 싶습니다. 이는 신규 사용자 확보 및 초기 활성화 단계를 이해하는 데 중요한 지표입니다. 결과는 단일 숫자로 제공해주세요.",
    "context": "신규 사용자가 얼마나 성공적으로 첫 구매를 완료하는지는 제품의 초기 만족도와 가치 전달을 나타내는 핵심 지표입니다. 이를 통해 onboarding 프로세스 개선 및 초기 사용자 획득 전략의 효과를 측정할 수 있습니다.",
    "submission_requirements": "첫 구매를 완료한 고유 사용자 ID의 총 수를 나타내는 단일 값(integer)을 반환합니다.",
    "answer_sql": "WITH first_purchase AS (\n    SELECT\n        user_id,\n        MIN(order_time) AS first_purchase_time\n    FROM\n        pa_orders\n    GROUP BY\n        user_id\n)\nSELECT\n    COUNT(DISTINCT fp.user_id)\nFROM\n    first_purchase fp\nJOIN\n    pa_users pu ON fp.user_id = pu.user_id\nWHERE\n    pu.signup_at <= fp.first_purchase_time;",
    "expected_description": "플랫폼에서 첫 구매를 완료한 고유 사용자의 총 수를 나타냅니다.",
    "expected_columns": [
      "count"
    ],
    "sort_keys": [],
    "hint": "pa_orders 테이블에서 각 user_id 별로 가장 이른 order_time을 찾습니다. 이 사용자들 중에서 pa_users 테이블의 signup_at 보다 첫 구매 시간이 늦은 경우만 집계하여 첫 구매 사용자를 식별합니다. DISTINCT를 사용하여 중복을 제거하고 COUNT 함수로 총 수를 셉니다.",
    "date": "2026-01-01",
    "set_index": 1,
    "xp_value": 3,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_commerce_sql_003_set1",
    "difficulty": "medium",
    "topic": "funnel",
    "requester": "마케팅팀",
    "question": "안녕하세요, 마케팅팀입니다. 최근 한 달간 (2025-12-01 ~ 2025-12-31) 사용자 여정의 주요 단계별 전환율을 분석하고 싶습니다. 특히 'view_product' -> 'add_to_cart' -> 'begin_checkout' -> 'purchase' 로 이어지는 퍼널의 각 단계별 전환율을 알고 싶습니다. 어떤 단계에서 이탈이 가장 많이 발생하는지 파악하여 마케팅 전략 수립에 활용하겠습니다. 결과는 전환율이 높은 순서대로 정렬해주세요.",
    "context": "사용자 행동 흐름을 이해하는 것은 전환율 최적화에 매우 중요합니다. 각 퍼널 단계별 이탈 지점을 파악함으로써, 해당 단계에 대한 개선 방안(예: UI/UX 개선, 프로모션 강화)을 마련할 수 있습니다.",
    "submission_requirements": "각 퍼널 단계별 이벤트 발생 수와 해당 단계의 전환율(이전 단계 대비)을 표시합니다. 결과는 전환율이 높은 순서대로 정렬합니다. 전환율은 소수점 넷째 자리까지 표시합니다.",
    "answer_sql": "WITH funnel_steps AS (\n    SELECT\n        'view_product' AS step,\n        COUNT(DISTINCT user_id) AS users\n    FROM\n        pa_events\n    WHERE\n        event_name = 'view_product'\n        AND event_time >= '2025-12-01 00:00:00'\n        AND event_time < '2026-01-01 00:00:00'\n\n    UNION ALL\n\n    SELECT\n        'add_to_cart' AS step,\n        COUNT(DISTINCT user_id) AS users\n    FROM\n        pa_events\n    WHERE\n        event_name = 'add_to_cart'\n        AND event_time >= '2025-12-01 00:00:00'\n        AND event_time < '2026-01-01 00:00:00'\n\n    UNION ALL\n\n    SELECT\n        'begin_checkout' AS step,\n        COUNT(DISTINCT user_id) AS users\n    FROM\n        pa_events\n    WHERE\n        event_name = 'begin_checkout'\n        AND event_time >= '2025-12-01 00:00:00'\n        AND event_time < '2026-01-01 00:00:00'\n\n    UNION ALL\n\n    SELECT\n        'purchase' AS step,\n        COUNT(DISTINCT user_id) AS users\n    FROM\n        pa_events\n    WHERE\n        event_name = 'purchase'\n        AND event_time >= '2025-12-01 00:00:00'\n        AND event_time < '2026-01-01 00:00:00'\n),\nfunnel_with_previous AS (\n    SELECT\n        step,\n        users,\n        LAG(users, 1, users) OVER (ORDER BY \n            CASE step\n                WHEN 'view_product' THEN 1\n                WHEN 'add_to_cart' THEN 2\n                WHEN 'begin_checkout' THEN 3\n                WHEN 'purchase' THEN 4\n            END\n        ) AS previous_step_users\n    FROM\n        funnel_steps\n)\nSELECT\n    step,\n    users AS step_users,\n    ROUND(CASE\n        WHEN previous_step_users = 0 THEN 0\n        ELSE CAST(users AS NUMERIC) / previous_step_users\n    END, 4) AS conversion_rate\nFROM\n    funnel_with_previous\nORDER BY\n    conversion_rate DESC;",
    "expected_description": "각 퍼널 단계별 사용자 수와 이전 단계 대비 전환율을 보여줍니다.",
    "expected_columns": [
      "step",
      "step_users",
      "conversion_rate"
    ],
    "sort_keys": [
      "conversion_rate"
    ],
    "hint": "각 퍼널 단계별로 distinct user_id 수를 집계합니다. LAG 함수를 사용하여 이전 단계의 사용자 수를 가져온 후, 현재 단계 사용자 수를 이전 단계 사용자 수로 나누어 전환율을 계산합니다. NULLIF 또는 CASE 문으로 division by zero를 방지합니다.",
    "date": "2026-01-01",
    "set_index": 1,
    "xp_value": 5,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_commerce_sql_004_set1",
    "difficulty": "medium",
    "topic": "retention",
    "requester": "CX팀",
    "question": "안녕하세요, CX팀입니다. 장바구니 이탈 현황을 분석하고 싶습니다. 'add_to_cart' 이벤트 후 24시간 이내에 'purchase' 또는 'remove_from_cart' 이벤트가 발생하지 않은 사용자를 장바구니 이탈 고객으로 정의합니다. 최근 한 달간 (2025-12-01 ~ 2025-12-31) 장바구니에 상품을 담았지만 구매하지 않고 이탈한 고객 수를 파악하고 싶습니다. 결과는 고객 ID 별로 정리하여, 어떤 고객이 이탈했는지 명확히 알 수 있도록 해주세요.",
    "context": "장바구니 이탈은 구매 전환의 마지막 단계를 놓치는 상황으로, 고객 경험 개선 및 매출 증대를 위해 반드시 분석해야 합니다. 이탈 고객의 특성을 파악하여 재방문 유도 및 구매 전환율 향상 전략을 수립할 수 있습니다.",
    "submission_requirements": "장바구니 이탈 고객의 user_id와 해당 고객이 상품을 장바구니에 담은 시점(add_to_cart 이벤트 시간)을 반환합니다. 결과는 add_to_cart_time 기준 오름차순 정렬합니다. 이탈 고객 수 합계를 마지막 행에 'TOTAL'이라는 user_id로 별도 표시해주세요.",
    "answer_sql": "WITH AddToCartEvents AS (\n    SELECT\n        user_id,\n        session_id,\n        event_time AS add_to_cart_time\n    FROM\n        pa_events\n    WHERE\n        event_name = 'add_to_cart'\n        AND event_time >= '2025-12-01 00:00:00'\n        AND event_time < '2026-01-01 00:00:00'\n),\n\nPurchaseOrRemoveEvents AS (\n    SELECT\n        user_id,\n        session_id,\n        event_time AS activity_time\n    FROM\n        pa_events\n    WHERE\n        event_name IN ('purchase', 'remove_from_cart')\n        AND event_time >= '2025-12-01 00:00:00'\n        AND event_time < '2026-01-01 00:00:00'\n),\n\nCartAbandonment AS (\n    SELECT\n        ate.user_id,\n        ate.session_id,\n        ate.add_to_cart_time\n    FROM\n        AddToCartEvents ate\n    LEFT JOIN\n        PurchaseOrRemoveEvents pre ON ate.user_id = pre.user_id AND ate.session_id = pre.session_id\n    WHERE\n        pre.activity_time IS NULL OR pre.activity_time > ate.add_to_cart_time + INTERVAL '24 hours'\n)\n\nSELECT user_id, add_to_cart_time FROM CartAbandonment\nUNION ALL\nSELECT 'TOTAL' as user_id, CAST(COUNT(*) AS NUMERIC) FROM CartAbandonment;",
    "expected_description": "장바구니에 상품을 담은 후 24시간 이내에 구매 또는 제거 이벤트가 발생하지 않은 고객의 ID와 해당 이벤트 시간을 보여줍니다. 마지막 행에는 총 이탈 고객 수가 표시됩니다.",
    "expected_columns": [
      "user_id",
      "add_to_cart_time"
    ],
    "sort_keys": [
      "add_to_cart_time"
    ],
    "hint": "먼저 'add_to_cart' 이벤트를 기록한 사용자와 시간을 추출합니다. 다음으로 'purchase' 또는 'remove_from_cart' 이벤트를 기록한 사용자와 시간을 추출합니다. JOIN 시 session_id를 함께 사용하여 동일 세션 내에서의 행동을 비교합니다. LEFT JOIN을 사용하여 add_to_cart 이벤트는 있지만 이후 이벤트가 없는 경우를 찾고, 조건절에서 24시간 이내 구매/제거가 없는 경우를 필터링합니다. UNION ALL을 사용하여 마지막에 총계를 추가합니다.",
    "date": "2026-01-01",
    "set_index": 1,
    "xp_value": 5,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_commerce_sql_005_set1",
    "difficulty": "hard",
    "topic": "revenue",
    "requester": "그로스팀",
    "question": "안녕하세요, 그로스팀입니다. 쿠폰 사용이 매출에 미치는 영향을 분석하고 싶습니다. 'apply_coupon' 이벤트를 발생시킨 사용자들의 구매액(amount)과, 'apply_coupon' 이벤트 없이 'purchase' 이벤트를 발생시킨 사용자들의 구매액을 비교하고 싶습니다. 이를 통해 쿠폰의 실질적인 효과를 측정하고 싶습니다. 분석 기간은 2025년 11월 15일부터 12월 29일까지로 설정합니다. 결과는 쿠폰 사용 여부에 따라 나누어, 각 그룹별 총 매출(GMV)과 평균 주문 금액(AOV)을 보여주세요.",
    "context": "쿠폰 마케팅은 고객 유치 및 구매 전환율 증대에 효과적이지만, 쿠폰 할인으로 인해 실제 매출에 미치는 순영향을 정확히 파악하는 것이 중요합니다. 이를 통해 쿠폰 전략의 ROI를 분석하고 최적화할 수 있습니다.",
    "submission_requirements": "결과는 'coupon_usage' 컬럼 ('Applied Coupon' 또는 'No Coupon')으로 구분하여 표시합니다. 각 그룹별 총 매출(GMV)은 정수, 평균 주문 금액(AOV)은 소수점 둘째 자리까지 반올림하여 표시합니다. 'No Coupon' 그룹은 'apply_coupon' 이벤트가 없는 사용자 중 'purchase' 이벤트를 발생시킨 사용자로 한정합니다.",
    "answer_sql": "WITH CouponAppliedPurchases AS (\n    SELECT\n        po.user_id,\n        po.amount\n    FROM\n        pa_orders po\n    JOIN\n        pa_events pe ON po.user_id = pe.user_id AND DATE(po.order_time) = DATE(pe.event_time)\n    WHERE\n        pe.event_name = 'apply_coupon'\n        AND pe.event_time >= '2025-11-15 00:00:00'\n        AND pe.event_time < '2025-12-30 00:00:00'\n        AND po.order_time >= '2025-11-15 00:00:00'\n        AND po.order_time < '2025-12-30 00:00:00'\n    GROUP BY po.order_id, po.user_id, po.amount -- 각 주문별 쿠폰 적용 여부를 정확히 파악하기 위해 order_id 포함\n),\n\nNoCouponPurchases AS (\n    SELECT\n        po.user_id,\n        po.amount\n    FROM\n        pa_orders po\n    WHERE\n        po.order_time >= '2025-11-15 00:00:00'\n        AND po.order_time < '2025-12-30 00:00:00'\n        AND po.user_id NOT IN (\n            SELECT DISTINCT user_id\n            FROM pa_events\n            WHERE event_name = 'apply_coupon'\n            AND event_time >= '2025-11-15 00:00:00'\n            AND event_time < '2025-12-30 00:00:00'\n        )\n)\n\nSELECT 'Applied Coupon' AS coupon_usage, SUM(amount) AS total_gmv, ROUND(AVG(amount), 2) AS average_aov FROM CouponAppliedPurchases\n\nUNION ALL\n\nSELECT 'No Coupon' AS coupon_usage, SUM(amount) AS total_gmv, ROUND(AVG(amount), 2) AS average_aov FROM NoCouponPurchases;",
    "expected_description": "쿠폰을 적용한 구매 그룹과 쿠폰을 적용하지 않은 구매 그룹으로 나누어, 각 그룹별 총 매출(GMV)과 평균 주문 금액(AOV)을 비교합니다.",
    "expected_columns": [
      "coupon_usage",
      "total_gmv",
      "average_aov"
    ],
    "sort_keys": [
      "coupon_usage"
    ],
    "hint": "쿠폰 적용 사용자 구매와 미적용 사용자 구매를 별도의 CTE(Common Table Expression)로 분리합니다. 'apply_coupon' 이벤트와 'purchase' 이벤트의 시간적 연관성을 고려해야 하며, 같은 날짜에 발생한 주문만을 대상으로 합니다. 'No Coupon' 그룹은 'apply_coupon' 이벤트 기록이 없는 사용자 중 구매를 한 경우로 정의합니다. 각 그룹별로 SUM과 AVG 함수를 적용하고 UNION ALL로 결과를 합칩니다.",
    "date": "2026-01-01",
    "set_index": 1,
    "xp_value": 8,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_commerce_sql_006_set1",
    "difficulty": "hard",
    "topic": "retention",
    "requester": "SCM팀",
    "question": "안녕하세요, SCM팀입니다. 재구매율이 높은 사용자 그룹을 파악하고 싶습니다. 'purchase' 이벤트를 두 번 이상 발생시킨 사용자들을 '재구매 고객'으로 정의합니다. 2025년 11월 1일부터 12월 29일까지의 기간 동안, 첫 구매 이후 최소 한 번 이상 재구매한 사용자들의 ID와 각 사용자의 재구매 횟수를 파악하여, 우수 고객 그룹의 특성을 분석하는 데 활용하겠습니다. 결과는 재구매 횟수가 많은 순서대로 정렬해주세요.",
    "context": "고객 유지율 증가는 장기적인 비즈니스 성장에 필수적입니다. 재구매 고객은 일반적으로 신규 고객보다 LTV(Lifetime Value)가 높기 때문에, 이들을 식별하고 이탈을 방지하는 것은 SCM 및 마케팅 전략의 중요한 목표입니다.",
    "submission_requirements": "재구매 고객의 user_id와 해당 고객의 총 재구매 횟수를 반환합니다. 결과는 재구매 횟수(reorder_count) 기준 내림차순으로 정렬합니다. 재구매 횟수가 0인 사용자는 결과에 포함하지 않습니다.",
    "answer_sql": "WITH CustomerPurchases AS (\n    SELECT\n        user_id,\n        order_time,\n        ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY order_time) as purchase_rank\n    FROM\n        pa_orders\n    WHERE\n        order_time >= '2025-11-01 00:00:00'\n        AND order_time < '2025-12-30 00:00:00'\n)\nSELECT\n    user_id,\n    COUNT(user_id) - 1 AS reorder_count\nFROM\n    CustomerPurchases\nWHERE\n    purchase_rank > 1\nGROUP BY\n    user_id\nORDER BY\n    reorder_count DESC;",
    "expected_description": "첫 구매 이후 두 번째 구매부터의 횟수를 기준으로 재구매 고객을 분류하고, 각 고객의 재구매 횟수를 내림차순으로 정렬하여 보여줍니다.",
    "expected_columns": [
      "user_id",
      "reorder_count"
    ],
    "sort_keys": [
      "reorder_count"
    ],
    "hint": "pa_orders 테이블에서 각 user_id 별로 order_time을 기준으로 순위를 매깁니다 (ROW_NUMBER 함수 사용). 첫 번째 구매 (purchase_rank = 1) 이후의 구매들만 집계하여 재구매 횟수를 계산합니다. GROUP BY user_id를 사용하여 각 사용자의 재구매 횟수를 집계하고, reorder_count가 0보다 큰 경우만 필터링하여 결과를 정렬합니다.",
    "date": "2026-01-01",
    "set_index": 1,
    "xp_value": 8,
    "expected_result": [],
    "expected_row_count": 0
  }
]
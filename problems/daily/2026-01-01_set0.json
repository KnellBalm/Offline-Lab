[
  {
    "problem_id": "2026-01-01_ecommerce_sql_001_set0",
    "difficulty": "easy",
    "topic": "revenue",
    "requester": "경영진",
    "question": "이번 달 (2025년 12월) 총 GMV와 AOV (Average Order Value) 추이를 일별로 보고 싶습니다. 날짜, 총 매출액, 일별 평균 주문 금액을 포함해야 합니다.",
    "context": "월간 경영 성과 보고를 위해 최근 GMV 및 AOV 변화 추이를 파악하는 것이 중요합니다. 특히 12월은 연말 특수 등으로 인해 매출 변동성이 클 수 있어 일별 추이를 분석하고자 합니다.",
    "submission_requirements": "결과는 'order_date' 기준 오름차순으로 정렬하며, 'daily_gmv'와 'daily_aov'는 소수점 둘째 자리까지 반올림하여 표시합니다.",
    "answer_sql": "SELECT\n    DATE(order_time) AS order_date,\n    SUM(amount) AS daily_gmv,\n    AVG(amount) AS daily_aov\nFROM\n    pa_orders\nWHERE\n    order_time >= '2025-12-01 00:00:00' AND order_time < '2026-01-01 00:00:00'\nGROUP BY\n    order_date\nORDER BY\n    order_date ASC;",
    "expected_description": "날짜별 총 매출액(GMV) 및 평균 주문 금액(AOV)을 보여주는 테이블입니다.",
    "expected_columns": [
      "order_date",
      "daily_gmv",
      "daily_aov"
    ],
    "sort_keys": [
      "order_date"
    ],
    "hint": "pa_orders 테이블에서 order_time 컬럼을 사용하여 날짜별로 그룹화하고, SUM 함수와 AVG 함수를 사용하세요. 날짜 조건은 '2025-12-01'부터 '2025-12-31'까지 포함하도록 설정하세요.",
    "date": "2026-01-01",
    "set_index": 0,
    "xp_value": 3,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_ecommerce_sql_002_set0",
    "difficulty": "easy",
    "topic": "activation",
    "requester": "그로스팀",
    "question": "첫 구매를 완료한 사용자(activation) 수를 채널별로 파악하고 싶습니다. 각 채널별 첫 구매 사용자 수와 그 비율(전체 첫 구매 사용자 대비)을 계산해주세요.",
    "context": "신규 사용자가 실제로 구매까지 이어지는지 채널별로 효과를 측정하는 것이 중요합니다. 이를 통해 어떤 채널이 효과적인 활성 사용자를 많이 데려오는지 파악하여 마케팅 전략에 반영하고자 합니다.",
    "answer_sql": "WITH FirstPurchaseUsers AS (\n    SELECT\n        user_id,\n        MIN(order_time) AS first_order_time\n    FROM\n        pa_orders\n    GROUP BY\n        user_id\n),\nUserFirstOrder AS (\n    SELECT\n        fpu.user_id,\n        pu.channel\n    FROM\n        FirstPurchaseUsers fpu\n    JOIN\n        pa_users pu ON fpu.user_id = pu.user_id\n    WHERE\n        pu.signup_at BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n        AND fpu.first_order_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nChannelFirstPurchase AS (\n    SELECT\n        channel,\n        COUNT(DISTINCT user_id) AS first_purchase_users\n    FROM\n        UserFirstOrder\n    GROUP BY\n        channel\n),\nTotalFirstPurchase AS (\n    SELECT\n        COUNT(DISTINCT user_id) AS total_first_purchase_users\n    FROM\n        UserFirstOrder\n)\nSELECT\n    cfp.channel,\n    cfp.first_purchase_users,\n    ROUND(cfp.first_purchase_users::NUMERIC / tfp.total_first_purchase_users * 100, 2) AS percentage\nFROM\n    ChannelFirstPurchase cfp,\n    TotalFirstPurchase tfp\nORDER BY\n    cfp.first_purchase_users DESC;",
    "expected_description": "각 채널별 첫 구매 사용자 수와 전체 첫 구매 사용자 대비 비율을 보여주는 테이블입니다.",
    "expected_columns": [
      "channel",
      "first_purchase_users",
      "percentage"
    ],
    "sort_keys": [
      "first_purchase_users"
    ],
    "hint": "먼저 pa_orders 테이블에서 각 사용자별 첫 구매 시점을 찾고, pa_users 테이블과 조인하여 채널 정보를 가져옵니다. 이후 채널별로 그룹화하여 첫 구매 사용자 수를 세고, 전체 첫 구매 사용자 수 대비 비율을 계산하세요. '2025-10-30' ~ '2025-12-29' 기간 내 가입 및 첫 구매 데이터를 사용해야 합니다.",
    "date": "2026-01-01",
    "set_index": 0,
    "xp_value": 3,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_ecommerce_sql_003_set0",
    "difficulty": "medium",
    "topic": "funnel",
    "requester": "PM팀",
    "question": "전체 사용자를 대상으로 'page_view'부터 'purchase'까지의 단계별 전환율을 분석하고 싶습니다. 각 단계별 사용자 수와 이전 단계 대비 전환율, 그리고 전체 'page_view' 대비 최종 'purchase' 전환율을 계산해주세요. 퍼널 분석을 위해 'page_view', 'add_to_cart', 'begin_checkout', 'purchase' 이벤트만 고려해주세요.",
    "context": "사용자 경험 개선을 위해 구매 전환 퍼널의 각 단계별 이탈 지점을 파악하는 것이 중요합니다. 각 단계에서 얼마나 많은 사용자가 이탈하는지 이해하면 문제점을 진단하고 개선 방안을 도출하는 데 도움이 됩니다.",
    "answer_sql": "WITH EventCounts AS (\n    SELECT\n        SUM(CASE WHEN event_name = 'page_view' THEN 1 ELSE 0 END) AS page_view_count,\n        SUM(CASE WHEN event_name = 'add_to_cart' THEN 1 ELSE 0 END) AS add_to_cart_count,\n        SUM(CASE WHEN event_name = 'begin_checkout' THEN 1 ELSE 0 END) AS begin_checkout_count,\n        SUM(CASE WHEN event_name = 'purchase' THEN 1 ELSE 0 END) AS purchase_count\n    FROM\n        pa_events\n    WHERE\n        event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nFunnelStages AS (\n    SELECT\n        'page_view' AS stage,\n        page_view_count AS count,\n        NULL AS prev_count\n    FROM EventCounts\n    UNION ALL\n    SELECT\n        'add_to_cart' AS stage,\n        add_to_cart_count AS count,\n        page_view_count AS prev_count\n    FROM EventCounts\n    UNION ALL\n    SELECT\n        'begin_checkout' AS stage,\n        begin_checkout_count AS count,\n        add_to_cart_count AS prev_count\n    FROM EventCounts\n    UNION ALL\n    SELECT\n        'purchase' AS stage,\n        purchase_count AS count,\n        begin_checkout_count AS prev_count\n    FROM EventCounts\n)\nSELECT\n    stage,\n    count,\n    CASE\n        WHEN stage = 'page_view' THEN 100.00\n        ELSE ROUND(count::NUMERIC / prev_count * 100, 2)\n    END AS conversion_rate_to_previous,\n    CASE\n        WHEN stage = 'page_view' THEN ROUND(count::NUMERIC / (SELECT page_view_count FROM EventCounts) * 100, 2)\n        WHEN stage = 'add_to_cart' THEN ROUND(count::NUMERIC / (SELECT page_view_count FROM EventCounts) * 100, 2)\n        WHEN stage = 'begin_checkout' THEN ROUND(count::NUMERIC / (SELECT page_view_count FROM EventCounts) * 100, 2)\n        WHEN stage = 'purchase' THEN ROUND(count::NUMERIC / (SELECT page_view_count FROM EventCounts) * 100, 2)\n    END AS overall_conversion_rate\nFROM\n    FunnelStages\nORDER BY\n    CASE stage\n        WHEN 'page_view' THEN 1\n        WHEN 'add_to_cart' THEN 2\n        WHEN 'begin_checkout' THEN 3\n        WHEN 'purchase' THEN 4\n    END ASC;",
    "expected_description": "구매 전환 퍼널의 각 단계별 사용자 수, 이전 단계 대비 전환율, 전체 'page_view' 대비 최종 전환율을 보여주는 테이블입니다.",
    "expected_columns": [
      "stage",
      "count",
      "conversion_rate_to_previous",
      "overall_conversion_rate"
    ],
    "sort_keys": [
      "stage"
    ],
    "hint": "먼저 pa_events 테이블에서 각 필수 이벤트의 총 발생 횟수를 집계합니다. CTE(Common Table Expression)를 활용하여 각 퍼널 단계를 정의하고, 이전 단계의 카운트를 사용하여 전환율을 계산하세요. 전체 page_view 대비 전환율 계산 시, 각 단계의 사용자 수를 총 page_view 수로 나누어 계산합니다. '2025-10-30' ~ '2025-12-29' 기간 내 데이터를 사용합니다.",
    "date": "2026-01-01",
    "set_index": 0,
    "xp_value": 5,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_ecommerce_sql_004_set0",
    "difficulty": "medium",
    "topic": "retention",
    "requester": "CX팀",
    "question": "장바구니에 상품을 담았지만 구매하지 않은 사용자(cart abandonment)의 행동 패턴을 분석하고 싶습니다. 장바구니에 상품을 담은 후, 최종 구매까지 이어지지 않은 사용자들이 주로 어떤 이벤트를 경험했는지, 어떤 디바이스를 사용했는지 파악하고자 합니다. 'add_to_cart' 이벤트 이후 'purchase' 이벤트가 발생하지 않은 사용자들의 'event_name'별 발생 빈도와 'device'별 발생 빈도를 각각 상위 5개씩 보여주세요.",
    "context": "장바구니 이탈은 매출 손실의 주요 원인 중 하나입니다. 이탈하는 사용자들의 특징을 이해하면 이탈을 방지하기 위한 프로모션이나 UI/UX 개선 방안을 마련하는 데 도움이 됩니다.",
    "answer_sql": "WITH UsersWithAdd AS (\n    SELECT DISTINCT\n        user_id\n    FROM\n        pa_events\n    WHERE\n        event_name = 'add_to_cart'\n        AND event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nUsersWithPurchase AS (\n    SELECT DISTINCT\n        user_id\n    FROM\n        pa_events\n    WHERE\n        event_name = 'purchase'\n        AND event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nCartAbandoners AS (\n    SELECT\n        uwa.user_id\n    FROM\n        UsersWithAdd uwa\n    LEFT JOIN\n        UsersWithPurchase uwp ON uwa.user_id = uwp.user_id\n    WHERE\n        uwp.user_id IS NULL\n),\nAbandonerEvents AS (\n    SELECT\n        pe.event_name,\n        COUNT(*) AS event_count\n    FROM\n        pa_events pe\n    JOIN\n        CartAbandoners ca ON pe.user_id = ca.user_id\n    WHERE\n        pe.event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n        AND pe.event_name <> 'add_to_cart' -- 장바구니 담기 이후 이탈 행동 분석\n    GROUP BY\n        pe.event_name\n),\nAbandonerDevices AS (\n    SELECT\n        ps.device,\n        COUNT(*) AS device_count\n    FROM\n        pa_sessions ps\n    JOIN\n        CartAbandoners ca ON ps.user_id = ca.user_id\n    WHERE\n        ps.started_at BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n    GROUP BY\n        ps.device\n)\nSELECT 'Event' as type, event_name as name, event_count as count FROM AbandonerEvents ORDER BY event_count DESC LIMIT 5\nUNION ALL\nSELECT 'Device' as type, device as name, device_count as count FROM AbandonerDevices ORDER BY device_count DESC LIMIT 5;",
    "expected_description": "장바구니 이탈 사용자들의 주요 이벤트 및 디바이스 사용 패턴을 보여주는 테이블입니다. 'type' 컬럼은 'Event' 또는 'Device'를 나타내며, 'name'은 이벤트명 또는 디바이스명, 'count'는 발생 빈도를 나타냅니다.",
    "expected_columns": [
      "type",
      "name",
      "count"
    ],
    "sort_keys": [
      "count"
    ],
    "hint": "먼저 'add_to_cart' 이벤트 이후 'purchase' 이벤트가 발생하지 않은 사용자를 식별합니다. 이를 위해 CTE를 활용하여 장바구니에 상품을 담은 사용자 ID와 구매한 사용자 ID를 분리하고, 구매하지 않은 사용자를 찾습니다. 해당 사용자들의 pa_events와 pa_sessions 테이블에서 발생하는 이벤트와 사용 디바이스를 집계하여 빈도를 계산합니다. '2025-10-30' ~ '2025-12-29' 기간 내 데이터를 사용하며, UNION ALL을 사용하여 이벤트와 디바이스별 결과를 합쳐 상위 5개씩 조회합니다.",
    "date": "2026-01-01",
    "set_index": 0,
    "xp_value": 5,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_ecommerce_sql_005_set0",
    "difficulty": "hard",
    "topic": "funnel",
    "requester": "그로스팀",
    "question": "쿠폰 적용(apply_coupon) 이후 구매(purchase)까지의 전환율을 분석하고 싶습니다. 특히, 쿠폰을 적용한 사용자 그룹과 적용하지 않은 사용자 그룹 간의 전환율 차이를 비교하고 싶습니다. 'apply_coupon' 이벤트가 발생하고, 그 이후 'purchase' 이벤트까지 발생한 사용자의 비율과, 'apply_coupon' 이벤트 없이 'purchase'까지 발생한 사용자의 비율을 비교 분석해주세요. 각 그룹의 'purchase' 전환율을 소수점 둘째 자리까지 반올림하여 표시해야 합니다.",
    "context": "마케팅 캠페인으로 배포되는 쿠폰의 실제 효과를 측정하는 것이 중요합니다. 쿠폰이 사용자들의 구매 결정에 얼마나 긍정적인 영향을 미치는지, 즉 쿠폰 사용이 매출 증대에 기여하는 정도를 정량적으로 파악하고자 합니다.",
    "answer_sql": "WITH UserEventSequence AS (\n    SELECT\n        user_id,\n        event_name,\n        event_time,\n        ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY event_time) as rn\n    FROM\n        pa_events\n    WHERE\n        event_name IN ('apply_coupon', 'purchase')\n        AND event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nCouponAppliedPurchasers AS (\n    SELECT DISTINCT\n        ues_coupon.user_id\n    FROM\n        UserEventSequence ues_coupon\n    JOIN\n        UserEventSequence ues_purchase ON ues_coupon.user_id = ues_purchase.user_id\n    WHERE\n        ues_coupon.event_name = 'apply_coupon'\n        AND ues_purchase.event_name = 'purchase'\n        AND ues_coupon.rn < ues_purchase.rn -- apply_coupon이 purchase보다 먼저 발생\n        AND ues_purchase.event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nNonCouponPurchasers AS (\n    SELECT DISTINCT\n        ues_purchase.user_id\n    FROM\n        UserEventSequence ues_purchase\n    LEFT JOIN\n        UserEventSequence ues_coupon ON ues_purchase.user_id = ues_coupon.user_id AND ues_coupon.event_name = 'apply_coupon' AND ues_coupon.rn < ues_purchase.rn\n    WHERE\n        ues_purchase.event_name = 'purchase'\n        AND ues_coupon.user_id IS NULL -- apply_coupon 이벤트가 purchase 이전에 발생하지 않음\n        AND ues_purchase.event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nTotalUsersWithPurchase AS (\n    SELECT DISTINCT user_id FROM pa_events WHERE event_name = 'purchase' AND event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nConversionRates AS (\n    SELECT\n        'Coupon Applied' AS group_type,\n        COUNT(DISTINCT cap.user_id) AS purchased_users,\n        (SELECT COUNT(DISTINCT user_id) FROM CouponAppliedPurchasers) AS total_users_in_group\n    FROM CouponAppliedPurchasers cap\n    UNION ALL\n    SELECT\n        'No Coupon Applied' AS group_type,\n        COUNT(DISTINCT ncp.user_id) AS purchased_users,\n        (SELECT COUNT(DISTINCT user_id) FROM NonCouponPurchasers) AS total_users_in_group\n    FROM NonCouponPurchasers ncp\n)\nSELECT\n    group_type,\n    purchased_users,\n    ROUND(purchased_users::NUMERIC / total_users_in_group * 100, 2) AS purchase_conversion_rate\nFROM\n    ConversionRates\nWHERE total_users_in_group > 0\nORDER BY\n    CASE group_type WHEN 'Coupon Applied' THEN 1 ELSE 2 END ASC;",
    "expected_description": "쿠폰 적용 사용자 그룹과 미적용 사용자 그룹별 구매 전환율을 비교하는 테이블입니다.",
    "expected_columns": [
      "group_type",
      "purchased_users",
      "purchase_conversion_rate"
    ],
    "sort_keys": [
      "group_type"
    ],
    "hint": "먼저 사용자의 이벤트 순서를 파악하기 위해 ROW_NUMBER() 윈도우 함수를 사용합니다. 'apply_coupon' 후 'purchase'가 발생한 사용자와, 'apply_coupon' 없이 'purchase'가 발생한 사용자를 각각 식별하는 CTE를 만듭니다. 이후 각 그룹의 구매 전환율을 계산하고 비교합니다. '2025-10-30' ~ '2025-12-29' 기간 내 데이터를 사용해야 합니다.",
    "date": "2026-01-01",
    "set_index": 0,
    "xp_value": 8,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_ecommerce_sql_006_set0",
    "difficulty": "hard",
    "topic": "retention",
    "requester": "SCM팀",
    "question": "전체 사용자의 재구매율(Repeat Purchase Rate)을 상품 비교(compare_product) 행동과 연관지어 분석하고 싶습니다. 상품 비교 행동을 많이 하는 사용자 그룹이 그렇지 않은 사용자 그룹에 비해 재구매율이 높은지 알고 싶습니다. 'compare_product' 이벤트 발생 횟수별로 사용자를 그룹화하고, 각 그룹의 재구매 사용자 수 및 재구매율을 계산해주세요. 재구매율은 (전체 구매자 중 재구매자 수) / (전체 구매자 수) 로 계산합니다.",
    "context": "고객들이 상품을 탐색하고 비교하는 행동이 실제 재구매로 이어지는지를 파악하여, 상품 비교 기능의 중요성과 잠재적 가치를 이해하고자 합니다. 이는 고객 충성도와 관련된 인사이트를 제공할 수 있습니다.",
    "answer_sql": "WITH UserCompareCounts AS (\n    SELECT\n        user_id,\n        COUNT(CASE WHEN event_name = 'compare_product' THEN 1 ELSE NULL END) AS compare_count\n    FROM\n        pa_events\n    WHERE\n        event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n    GROUP BY\n        user_id\n),\nUserFirstPurchase AS (\n    SELECT\n        user_id,\n        MIN(order_time) AS first_order_time\n    FROM\n        pa_orders\n    WHERE\n        order_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n    GROUP BY\n        user_id\n),\nUserRepeatPurchase AS (\n    SELECT\n        user_id,\n        COUNT(order_id) AS repeat_purchase_count\n    FROM\n        pa_orders\n    WHERE\n        order_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n    GROUP BY\n        user_id\n    HAVING\n        COUNT(order_id) > 1\n),\nUserPurchaseGroups AS (\n    SELECT\n        ucc.user_id,\n        CASE\n            WHEN ucc.compare_count = 0 THEN '0 Compare'\n            WHEN ucc.compare_count BETWEEN 1 AND 5 THEN '1-5 Compares'\n            WHEN ucc.compare_count > 5 THEN '6+ Compares'\n            ELSE 'No Compare Data' -- compare_product 이벤트가 전혀 없는 경우\n        END AS compare_group\n    FROM\n        UserCompareCounts ucc\n    WHERE\n        ucc.user_id IN (SELECT user_id FROM UserFirstPurchase)\n),\nTotalPurchasersByGroup AS (\n    SELECT\n        upg.compare_group,\n        COUNT(DISTINCT upg.user_id) AS total_purchasers\n    FROM\n        UserPurchaseGroups upg\n    GROUP BY\n        upg.compare_group\n),\nRepeatPurchasersByGroup AS (\n    SELECT\n        upg.compare_group,\n        COUNT(DISTINCT urp.user_id) AS repeat_purchasers\n    FROM\n        UserPurchaseGroups upg\n    JOIN\n        UserRepeatPurchase urp ON upg.user_id = urp.user_id\n    GROUP BY\n        upg.compare_group\n)\nSELECT\n    tpg.compare_group,\n    tpg.total_purchasers,\n    COALESCE(rpg.repeat_purchasers, 0) AS repeat_purchasers,\n    ROUND(\n        CASE\n            WHEN tpg.total_purchasers = 0 THEN 0\n            ELSE COALESCE(rpg.repeat_purchasers, 0)::NUMERIC / tpg.total_purchasers * 100\n        END,\n        2\n    ) AS repeat_purchase_rate\nFROM\n    TotalPurchasersByGroup tpg\nLEFT JOIN\n    RepeatPurchasersByGroup rpg ON tpg.compare_group = rpg.compare_group\nORDER BY\n    CASE tpg.compare_group\n        WHEN '0 Compare' THEN 1\n        WHEN '1-5 Compares' THEN 2\n        WHEN '6+ Compares' THEN 3\n        WHEN 'No Compare Data' THEN 4\n    END ASC;",
    "expected_description": "상품 비교 횟수 그룹별 전체 구매자 수, 재구매자 수, 재구매율을 보여주는 테이블입니다.",
    "expected_columns": [
      "compare_group",
      "total_purchasers",
      "repeat_purchasers",
      "repeat_purchase_rate"
    ],
    "sort_keys": [
      "compare_group"
    ],
    "hint": "먼저 사용자별 'compare_product' 이벤트 발생 횟수를 집계합니다. 그다음, 각 사용자의 첫 구매 시점과 재구매 여부를 판단하기 위해 pa_orders 테이블을 활용합니다. 'compare_product' 횟수별로 사용자를 그룹화하고, 각 그룹의 전체 구매자 수와 재구매자 수를 계산하여 재구매율을 산출합니다. '2025-10-30' ~ '2025-12-29' 기간 내 데이터를 사용해야 하며, COALESCE 함수를 사용하여 재구매자 수가 0인 경우를 처리하고, division by zero 방지를 위해 CASE 문을 사용합니다.",
    "date": "2026-01-01",
    "set_index": 0,
    "xp_value": 8,
    "expected_result": [],
    "expected_row_count": 0
  }
]
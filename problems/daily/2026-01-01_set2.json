[
  {
    "problem_id": "2026-01-01_ecommerce_sql_001_set2",
    "difficulty": "easy",
    "topic": "revenue",
    "requester": "경영진",
    "question": "안녕하세요, 경영진입니다. 최근 1개월 간 일별 GMV(Gross Merchandise Value) 추이를 파악하고 싶습니다. 특히, 매출 발생액이 높은 순서대로 상위 5일을 보고해주시면 감사하겠습니다. 결과는 날짜별 총 매출액을 기준으로 내림차순 정렬해주세요.",
    "context": "회사의 전반적인 매출 성과를 파악하고, 특정 기간 동안의 매출 변동 추이를 이해하기 위함입니다. 이를 통해 향후 프로모션 계획 수립 및 비즈니스 전략 결정에 활용하고자 합니다.",
    "submission_requirements": "결과는 date 컬럼과 daily_gmv 컬럼으로 구성되며, daily_gmv 컬럼은 소수점 둘째 자리까지 반올림하여 표시합니다. 결과는 daily_gmv 기준 내림차순으로 정렬하고, 상위 5개의 데이터만 보여줍니다.",
    "answer_sql": "SELECT\n    DATE(order_time) AS date,\n    ROUND(SUM(amount), 2) AS daily_gmv\nFROM\n    pa_orders\nWHERE\n    order_time >= '2025-11-29' AND order_time < '2025-12-30' -- 지난 1개월 (2025-11-29 ~ 2025-12-29)\nGROUP BY\n    date\nORDER BY\n    daily_gmv DESC\nLIMIT 5;",
    "expected_description": "지정된 기간 동안 일별 총 매출액 (GMV)을 나타내는 테이블입니다. 각 행은 특정 날짜와 해당 날짜의 총 매출액을 포함합니다.",
    "expected_columns": [
      "date",
      "daily_gmv"
    ],
    "sort_keys": [
      "daily_gmv"
    ],
    "hint": "pa_orders 테이블의 order_time 컬럼에서 날짜 정보만 추출하고, amount 컬럼의 합계를 계산하여 일별 총 매출액을 구합니다. 날짜 범위는 2025년 11월 29일부터 2025년 12월 29일까지로 설정하고, 가장 높은 매출을 보인 상위 5일을 보여주기 위해 ORDER BY DESC 및 LIMIT 구문을 사용합니다.",
    "date": "2026-01-01",
    "set_index": 2,
    "xp_value": 3,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_ecommerce_sql_002_set2",
    "difficulty": "easy",
    "topic": "activation",
    "requester": "PM팀",
    "question": "안녕하세요, PM팀입니다. 2025년 12월 기준으로 첫 구매(purchase 이벤트 발생)를 완료한 신규 고객 수를 파악하고 싶습니다. 첫 구매일은 user_id별로 가장 먼저 발생하는 purchase 이벤트의 시간으로 정의합니다. 결과는 전체 신규 고객 수만 표시해주시면 됩니다.",
    "context": "신규 고객의 활성화 상태를 파악하고, 온보딩 프로세스의 효과를 측정하기 위함입니다. 이를 통해 향후 신규 고객 확보 전략 및 캠페인 최적화에 기여하고자 합니다.",
    "submission_requirements": "결과는 'new_customer_count'라는 단일 컬럼으로 표시되며, 정수형 값입니다.",
    "answer_sql": "WITH first_purchase AS (\n    SELECT\n        user_id,\n        MIN(event_time) AS first_purchase_time\n    FROM\n        pa_events\n    WHERE\n        event_name = 'purchase'\n    GROUP BY\n        user_id\n)\nSELECT\n    COUNT(fp.user_id) AS new_customer_count\nFROM\n    first_purchase fp\nJOIN\n    pa_users u ON fp.user_id = u.user_id\nWHERE\n    fp.first_purchase_time >= '2025-12-01' AND fp.first_purchase_time < '2026-01-01';",
    "expected_description": "2025년 12월 기준으로 첫 구매를 완료한 신규 고객 수를 나타내는 단일 값입니다. 'new_customer_count'라는 컬럼명으로 표시됩니다.",
    "expected_columns": [
      "new_customer_count"
    ],
    "sort_keys": [],
    "hint": "먼저, pa_events 테이블에서 'purchase' 이벤트만 필터링하여 각 user_id별 최초 구매 시간을 계산하는 CTE(Common Table Expression)를 생성합니다. 그 후, 이 CTE와 pa_users 테이블을 조인하고, 최초 구매 시간이 2025년 12월 내에 속하는 사용자 수를 세어 첫 구매 고객 수를 산출합니다.",
    "date": "2026-01-01",
    "set_index": 2,
    "xp_value": 3,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_ecommerce_sql_003_set2",
    "difficulty": "medium",
    "topic": "funnel",
    "requester": "그로스팀",
    "question": "그로스팀입니다. 'view_product' 이벤트 이후 'add_to_cart' 이벤트로 전환하는 고객들의 전환율을 계산하고 싶습니다. 분석 기간은 2025년 11월 1일부터 2025년 11월 30일까지로 설정해주세요. 전환율은 (add_to_cart 이벤트 발생 사용자 수 / view_product 이벤트 발생 사용자 수) * 100 으로 계산하며, 소수점 둘째 자리까지 표시해주세요. 결과는 'view_to_cart_conversion_rate'라는 컬럼명으로 표시합니다.",
    "context": "상품 상세 페이지가 장바구니 담기로 얼마나 잘 이어지는지 파악하여, 상품 페이지의 매력도나 정보 전달의 효과를 측정하고 싶습니다. 이를 통해 상품 상세 페이지 개선 방향을 도출하고자 합니다.",
    "submission_requirements": "결과는 'view_to_cart_conversion_rate'라는 단일 컬럼으로 표시되며, 소수점 둘째 자리까지 반올림된 실수형 값입니다. 결과는 오름차순 또는 내림차순 정렬이 필요하지 않습니다.",
    "answer_sql": "WITH event_counts AS (\n    SELECT\n        SUM(CASE WHEN event_name = 'view_product' THEN 1 ELSE 0 END) AS view_product_users,\n        SUM(CASE WHEN event_name = 'add_to_cart' THEN 1 ELSE 0 END) AS add_to_cart_users\n    FROM\n        pa_events\n    WHERE\n        event_time BETWEEN '2025-11-01 00:00:00' AND '2025-11-30 23:59:59'\n)\nSELECT\n    ROUND(NULLIF(ec.add_to_cart_users, 0) * 100.0 / NULLIF(ec.view_product_users, 0), 2) AS view_to_cart_conversion_rate\nFROM\n    event_counts ec;",
    "expected_description": "2025년 11월 한 달 동안 'view_product' 이벤트 발생 사용자 대비 'add_to_cart' 이벤트 발생 사용자의 비율을 나타내는 전환율입니다. 'view_to_cart_conversion_rate'라는 컬럼명으로 표시됩니다.",
    "expected_columns": [
      "view_to_cart_conversion_rate"
    ],
    "sort_keys": [],
    "hint": "pa_events 테이블에서 'view_product'와 'add_to_cart' 이벤트를 카운트하는 CTE를 만듭니다. 이 CTE를 사용하여 전환율을 계산할 때, 0으로 나누는 오류를 방지하기 위해 NULLIF 함수를 사용합니다. 전환율은 100을 곱하여 백분율로 표시하고, 소수점 둘째 자리까지 반올림합니다.",
    "date": "2026-01-01",
    "set_index": 2,
    "xp_value": 5,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_ecommerce_sql_004_set2",
    "difficulty": "medium",
    "topic": "retention",
    "requester": "CX팀",
    "question": "CX팀입니다. 장바구니에 상품을 담았지만 최종 구매(purchase)로 이어지지 않은 고객들의 세션을 분석하고 싶습니다. 'add_to_cart' 이벤트는 발생했지만 'purchase' 이벤트가 발생하지 않은 세션 ID와 해당 세션의 총 이벤트 수를 파악하고 싶습니다. 분석 기간은 2025년 12월 1일부터 2025년 12월 15일까지로 해주세요. 결과는 세션 ID 기준으로 오름차순 정렬해주세요.",
    "context": "장바구니 단계에서의 고객 이탈 원인을 파악하고, 이를 개선하기 위한 전략을 수립하는 데 활용하고자 합니다. 어떤 세션에서 이탈이 많이 발생하는지, 그리고 해당 세션에서는 어떤 행동이 주로 나타나는지 파악하는 것이 중요합니다.",
    "submission_requirements": "결과는 session_id와 total_events 컬럼으로 구성됩니다. total_events는 해당 세션 내의 총 이벤트 수를 나타내며, 정수형입니다. 결과는 session_id 컬럼 기준 오름차순으로 정렬됩니다.",
    "answer_sql": "WITH cart_added_sessions AS (\n    SELECT DISTINCT\n        session_id\n    FROM\n        pa_events\n    WHERE\n        event_name = 'add_to_cart'\n        AND event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-15 23:59:59'\n),\nnot_purchased_sessions AS (\n    SELECT DISTINCT\n        session_id\n    FROM\n        pa_events\n    WHERE\n        event_name = 'purchase'\n        AND event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-15 23:59:59'\n),\nsessions_with_event_count AS (\n    SELECT\n        session_id,\n        COUNT(event_id) AS total_events\n    FROM\n        pa_events\n    WHERE\n        event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-15 23:59:59'\n    GROUP BY\n        session_id\n)\nSELECT\n    sac.session_id,\n    sec.total_events\nFROM\n    cart_added_sessions sac\nLEFT JOIN\n    not_purchased_sessions nps ON sac.session_id = nps.session_id\nJOIN\n    sessions_with_event_count sec ON sac.session_id = sec.session_id\nWHERE\n    nps.session_id IS NULL\nORDER BY\n    sac.session_id ASC;",
    "expected_description": "2025년 12월 1일부터 15일까지 'add_to_cart' 이벤트는 발생했지만 'purchase' 이벤트는 발생하지 않은 세션의 ID와 해당 세션 내 총 이벤트 수를 보여주는 테이블입니다. 'session_id'와 'total_events' 컬럼으로 구성됩니다.",
    "expected_columns": [
      "session_id",
      "total_events"
    ],
    "sort_keys": [
      "session_id"
    ],
    "hint": "먼저 'add_to_cart'가 발생한 세션과 'purchase'가 발생하지 않은 세션을 각각 CTE로 분리합니다. 이후, 'add_to_cart'는 발생했지만 'purchase'는 발생하지 않은 세션만 추출하기 위해 LEFT JOIN과 WHERE IS NULL 구문을 사용합니다. 마지막으로, 추출된 세션들의 총 이벤트 수를 계산하여 결과를 조합합니다.",
    "date": "2026-01-01",
    "set_index": 2,
    "xp_value": 5,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_ecommerce_sql_005_set2",
    "difficulty": "hard",
    "topic": "retention",
    "requester": "마케팅팀",
    "question": "마케팅팀입니다. 2025년 12월에 첫 구매를 한 사용자 그룹(cohort)의 1개월 후 재구매율을 분석하고 싶습니다. 즉, 2025년 12월에 첫 구매를 완료한 사용자들이 다음 달(2026년 1월)에 다시 구매를 하는 비율을 알고 싶습니다. 첫 구매일은 pa_orders 테이블의 order_time을 기준으로 판단합니다. 재구매율은 (2026년 1월에 재구매한 사용자 수 / 2025년 12월 첫 구매자 수) * 100으로 계산해주세요. 결과는 'retention_rate_1m' 컬럼으로 표시하며, 소수점 둘째 자리까지 반올림합니다.",
    "context": "신규 고객 확보 후 얼마나 효과적으로 고객을 유지하고 재구매를 유도하는지 파악하여, 고객 생애 가치(CLTV) 증대를 위한 마케팅 전략 수립의 기초 자료로 활용하고자 합니다.",
    "submission_requirements": "결과는 'retention_rate_1m'이라는 단일 컬럼으로 표시되며, 소수점 둘째 자리까지 반올림된 실수형 값입니다. 결과는 정렬이 필요하지 않습니다.",
    "answer_sql": "WITH first_purchase_users AS (\n    SELECT\n        user_id,\n        MIN(order_time) AS first_order_time\n    FROM\n        pa_orders\n    WHERE\n        order_time >= '2025-12-01 00:00:00' AND order_time < '2026-01-01 00:00:00'\n    GROUP BY\n        user_id\n),\nsubsequent_purchases AS (\n    SELECT DISTINCT\n        o.user_id\n    FROM\n        pa_orders o\n    JOIN\n        first_purchase_users fpu ON o.user_id = fpu.user_id\n    WHERE\n        o.order_time >= '2026-01-01 00:00:00' AND o.order_time < '2026-02-01 00:00:00'\n)\nSELECT\n    ROUND(CAST(COUNT(sp.user_id) AS NUMERIC) * 100.0 / COUNT(fpu.user_id), 2) AS retention_rate_1m\nFROM\n    first_purchase_users fpu\nLEFT JOIN\n    subsequent_purchases sp ON fpu.user_id = sp.user_id;",
    "expected_description": "2025년 12월에 첫 구매를 한 사용자 그룹의 1개월 후 재구매율을 나타냅니다. 'retention_rate_1m'이라는 컬럼명으로 표시되며, 백분율로 표현됩니다.",
    "expected_columns": [
      "retention_rate_1m"
    ],
    "sort_keys": [],
    "hint": "첫 번째 CTE에서는 pa_orders 테이블을 사용하여 2025년 12월에 첫 구매를 한 사용자들의 user_id와 첫 구매 시간을 추출합니다. 두 번째 CTE에서는 이 첫 구매자들 중에서 2026년 1월에 다시 구매한 사용자들의 user_id를 추출합니다. 마지막으로, 첫 구매자 수를 분모로, 1개월 후 재구매자 수를 분자로 하여 재구매율을 계산하고 소수점 둘째 자리까지 반올림합니다. COUNT 함수 사용 시, 분모가 0이 되는 경우를 방지하기 위해 LEFT JOIN과 COUNT(sp.user_id)를 활용합니다.",
    "date": "2026-01-01",
    "set_index": 2,
    "xp_value": 8,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-01_ecommerce_sql_006_set2",
    "difficulty": "hard",
    "topic": "funnel",
    "requester": "그로스팀",
    "question": "그로스팀입니다. 'apply_coupon' 이벤트 발생 후 'purchase' 이벤트까지 성공적으로 이어진 고객들의 평균 쿠폰 사용액을 분석하고 싶습니다. 또한, 쿠폰 적용 없이 구매한 고객들의 평균 구매 금액과 비교하여 쿠폰의 효과를 정량적으로 평가하고 싶습니다. 분석 기간은 2025년 12월 1일부터 2025년 12월 31일까지입니다. 결과는 'coupon_applied_avg_amount'와 'no_coupon_avg_amount' 두 컬럼으로 보여주세요.",
    "context": "쿠폰 프로모션의 실제 효과를 파악하고, 쿠폰이 고객의 구매 결정에 미치는 영향을 분석하여 향후 쿠폰 발행 전략 수립에 활용하고자 합니다. 쿠폰 사용 그룹과 미사용 그룹의 평균 구매 금액을 비교 분석하는 것이 중요합니다.",
    "submission_requirements": "결과는 'coupon_applied_avg_amount'와 'no_coupon_avg_amount' 두 컬럼으로 구성되며, 모두 소수점 둘째 자리까지 반올림된 실수형 값입니다. 결과는 정렬이 필요하지 않습니다.",
    "answer_sql": "WITH coupon_purchase AS (\n    SELECT\n        o.user_id,\n        o.amount\n    FROM\n        pa_orders o\n    JOIN (\n        SELECT DISTINCT\n            user_id\n        FROM\n            pa_events\n        WHERE\n            event_name = 'apply_coupon'\n            AND event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n    ) AS cp_users ON o.user_id = cp_users.user_id\n    WHERE\n        o.order_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n),\nno_coupon_purchase AS (\n    SELECT\n        o.user_id,\n        o.amount\n    FROM\n        pa_orders o\n    WHERE\n        o.user_id NOT IN (\n            SELECT DISTINCT user_id FROM pa_events WHERE event_name = 'apply_coupon' AND event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n        )\n        AND o.order_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n)\nSELECT\n    ROUND(COALESCE(AVG(cp.amount), 0), 2) AS coupon_applied_avg_amount,\n    ROUND(COALESCE(AVG(ncp.amount), 0), 2) AS no_coupon_avg_amount\nFROM\n    coupon_purchase cp\nFULL OUTER JOIN\n    no_coupon_purchase ncp ON cp.user_id = ncp.user_id;",
    "expected_description": "2025년 12월 한 달 동안 쿠폰을 적용하여 구매한 고객들의 평균 구매 금액과 쿠폰을 적용하지 않고 구매한 고객들의 평균 구매 금액을 비교하는 테이블입니다. 'coupon_applied_avg_amount'와 'no_coupon_avg_amount' 두 컬럼으로 구성됩니다.",
    "expected_columns": [
      "coupon_applied_avg_amount",
      "no_coupon_avg_amount"
    ],
    "sort_keys": [],
    "hint": "두 개의 CTE를 생성합니다. 첫 번째 CTE ('coupon_purchase')는 'apply_coupon' 이벤트가 발생한 사용자의 구매 기록을 추출합니다. 두 번째 CTE ('no_coupon_purchase')는 'apply_coupon' 이벤트가 발생하지 않은 사용자의 구매 기록을 추출합니다. 마지막으로, 두 CTE를 FULL OUTER JOIN하여 쿠폰 적용 그룹과 미적용 그룹의 평균 구매 금액을 계산하고, COALESCE 함수를 사용하여 NULL 값을 0으로 처리합니다.",
    "date": "2026-01-01",
    "set_index": 2,
    "xp_value": 8,
    "expected_result": [],
    "expected_row_count": 0
  }
]
[
  {
    "problem_id": "community_sql_001_set2",
    "difficulty": "easy",
    "topic": "segmentation",
    "requester": "PM팀",
    "question": "안녕하세요 PM팀입니다. 최근 사용자 활동 패턴을 이해하기 위해, 가입 채널별 신규 사용자들의 '좋아요(like)'와 '댓글(comment)' 수를 집계하고 싶습니다. 각 채널별 총 좋아요 수와 총 댓글 수를 알려주세요. 결과는 총 좋아요 수가 많은 순서대로 정렬 부탁드립니다.",
    "context": "플랫폼 성장에 기여하는 핵심 채널을 파악하고, 각 채널별 사용자들의 참여도를 분석하여 마케팅 전략 수립에 활용하고자 합니다.",
    "submission_requirements": "결과는 'channel' 컬럼 기준 내림차순 정렬, 'total_likes'와 'total_comments' 컬럼은 정수형으로 표시해주세요.",
    "answer_sql": "WITH\n  ChannelEventCounts AS (\n    SELECT\n      pu.channel,\n      COUNT(CASE WHEN pe.event_name = 'like' THEN pe.event_id ELSE NULL END) AS likes,\n      COUNT(CASE WHEN pe.event_name = 'comment' THEN pe.event_id ELSE NULL END) AS comments\n    FROM\n      pa_users pu\n      JOIN pa_events pe ON pu.user_id = pe.user_id\n    WHERE\n      pu.signup_at BETWEEN '2025-10-28 00:00:00' AND '2025-12-27 23:59:59'\n      AND pe.event_time BETWEEN '2025-10-28 00:00:00' AND '2025-12-27 23:59:59'\n    GROUP BY\n      pu.channel\n  )\nSELECT\n  channel,\n  SUM(likes) AS total_likes,\n  SUM(comments) AS total_comments\nFROM\n  ChannelEventCounts\nGROUP BY\n  channel\nORDER BY\n  total_likes DESC;",
    "expected_description": "각 가입 채널별로 집계된 총 좋아요 수와 총 댓글 수를 보여줍니다. 'total_likes'가 많은 순서대로 정렬됩니다.",
    "expected_columns": [
      "channel",
      "total_likes",
      "total_comments"
    ],
    "sort_keys": [
      "total_likes DESC"
    ],
    "hint": "pa_users와 pa_events 테이블을 user_id로 조인하고, CASE 문을 사용하여 각 이벤트의 개수를 세고, GROUP BY와 SUM 함수를 활용하여 채널별 합계를 구하세요.",
    "xp_value": 3,
    "expected_meta": {
      "row_count": 4,
      "columns": [
        {
          "name": "channel",
          "type": "text"
        },
        {
          "name": "total_likes",
          "type": "numeric"
        },
        {
          "name": "total_comments",
          "type": "numeric"
        }
      ],
      "grading_table": "grading.expected_community_sql_001_set2"
    }
  },
  {
    "problem_id": "community_sql_002_set2",
    "difficulty": "easy",
    "topic": "activation",
    "requester": "그로스팀",
    "question": "안녕하세요, 그로스팀입니다. 신규 사용자가 처음으로 '포스트 작성(post_create)'을 완료하는 데 걸리는 시간을 분석하고 싶습니다. 가입일로부터 첫 포스트 작성일까지의 평균 일수를 계산해주세요. 결과는 소수점 둘째 자리까지 반올림하여 표시해주세요.",
    "context": "신규 사용자의 활성화(Activation) 지표로 첫 포스트 작성 시간을 추적하여, 온보딩 프로세스의 효율성을 점검하고 개선점을 찾기 위함입니다.",
    "submission_requirements": "결과는 'average_days_to_first_post' 컬럼으로 제시하며, 소수점 둘째 자리까지 반올림합니다. 반환되는 값은 숫자형이어야 합니다.",
    "answer_sql": "WITH FirstPost AS (\n    SELECT\n        user_id,\n        MIN(event_time) AS first_post_time\n    FROM\n        pa_events\n    WHERE\n        event_name = 'post_create'\n    GROUP BY\n        user_id\n)\nSELECT\n    ROUND(AVG(DATE_PART('day', fp.first_post_time - pu.signup_at)), 2) AS average_days_to_first_post\nFROM\n    pa_users pu\nJOIN\n    FirstPost fp ON pu.user_id = fp.user_id\nWHERE\n    pu.signup_at BETWEEN '2025-10-28 00:00:00' AND '2025-12-27 23:59:59';",
    "expected_description": "신규 사용자의 가입일로부터 첫 포스트 작성까지 걸리는 평균 일수를 보여줍니다. 소수점 둘째 자리까지 반올림됩니다.",
    "expected_columns": [
      "average_days_to_first_post"
    ],
    "sort_keys": [],
    "hint": "pa_users와 pa_events 테이블을 user_id로 조인하여, 각 사용자의 signup_at과 첫 post_create 이벤트 시간을 찾습니다. DATE_PART 함수를 사용하여 두 날짜 간의 차이를 일 단위로 계산하고 AVG 함수로 평균을 구하세요.",
    "xp_value": 3,
    "expected_meta": {
      "error": "function round(double precision, integer) does not exist\nLINE 13:     ROUND(AVG(DATE_PART('day', fp.first_post_time - pu.signu...\n             ^\nHINT:  No function matches the given name and argument types. You might need to add explicit type casts.\n"
    }
  },
  {
    "problem_id": "community_sql_003_set2",
    "difficulty": "medium",
    "topic": "engagement",
    "requester": "커뮤니티팀",
    "question": "안녕하세요, 커뮤니티팀입니다. 사용자 참여율 분석을 위해 '피드 보기(view_feed)' 대비 '좋아요(like)' 및 '댓글(comment)' 비율을 계산하고 싶습니다. 일별로 'Engagement Rate'를 계산하고, 가장 높은 Engagement Rate를 기록한 상위 5일의 날짜와 해당 Engagement Rate를 알려주세요. Engagement Rate는 (좋아요 수 + 댓글 수) / 피드 보기 수 로 계산합니다. 0으로 나누는 경우를 방지해야 합니다.",
    "context": "사용자 참여를 유도하는 콘텐츠나 활동의 효과를 측정하고, 참여가 높은 날짜의 패턴을 분석하여 커뮤니티 활성화 전략에 활용하고자 합니다.",
    "submission_requirements": "결과는 'activity_date'와 'engagement_rate' 두 개의 컬럼으로 구성되며, engagement_rate는 소수점 넷째 자리까지 반올림합니다. engagement_rate가 높은 순서대로 상위 5일만 출력해주세요.",
    "answer_sql": "WITH DailyEventCounts AS (\n    SELECT\n        DATE(event_time) AS activity_date,\n        COUNT(CASE WHEN event_name = 'view_feed' THEN event_id ELSE NULL END) AS view_feed_count,\n        COUNT(CASE WHEN event_name = 'like' THEN event_id ELSE NULL END) AS like_count,\n        COUNT(CASE WHEN event_name = 'comment' THEN event_id ELSE NULL END) AS comment_count\n    FROM\n        pa_events\n    WHERE\n        event_time BETWEEN '2025-10-28 00:00:00' AND '2025-12-27 23:59:59'\n        AND event_name IN ('view_feed', 'like', 'comment')\n    GROUP BY\n        DATE(event_time)\n)\nSELECT\n    activity_date,\n    ROUND(CAST(like_count + comment_count AS NUMERIC) / NULLIF(view_feed_count, 0), 4) AS engagement_rate\nFROM\n    DailyEventCounts\nWHERE\n    view_feed_count > 0\nORDER BY\n    engagement_rate DESC\nLIMIT 5;",
    "expected_description": "일별 Engagement Rate (좋아요 + 댓글 수 / 피드 보기 수)를 계산하여, 가장 높은 Engagement Rate를 기록한 상위 5일의 날짜와 해당 Engagement Rate를 보여줍니다. 0으로 나누는 경우를 방지합니다.",
    "expected_columns": [
      "activity_date",
      "engagement_rate"
    ],
    "sort_keys": [
      "engagement_rate DESC"
    ],
    "hint": "pa_events 테이블에서 일별로 view_feed, like, comment 이벤트 수를 집계합니다. DATE 함수를 사용하여 날짜별로 그룹화하고, CASE 문으로 각 이벤트 수를 센 후, NULLIF 함수를 사용하여 0으로 나누는 경우를 방지하고 engagement_rate를 계산합니다.",
    "xp_value": 5,
    "expected_meta": {
      "row_count": 5,
      "columns": [
        {
          "name": "activity_date",
          "type": "date"
        },
        {
          "name": "engagement_rate",
          "type": "numeric"
        }
      ],
      "grading_table": "grading.expected_community_sql_003_set2"
    }
  },
  {
    "problem_id": "community_sql_004_set2",
    "difficulty": "medium",
    "topic": "segmentation",
    "requester": "마케팅팀",
    "question": "안녕하세요, 마케팅팀입니다. 영향력 있는 사용자(influencer) 세그먼트를 정의하기 위해, '좋아요(like)'를 가장 많이 받은 '포스트 생성(post_create)' 이벤트 수를 기준으로 사용자 순위를 매기고 싶습니다. 각 사용자가 생성한 포스트 중 가장 많은 좋아요를 받은 포스트의 좋아요 수와, 해당 사용자의 총 포스트 생성 수를 집계해주세요. 결과는 좋아요 수가 많은 순서대로 상위 10명만 보여주세요.",
    "context": "플랫폼 내에서 영향력을 행사하는 사용자를 식별하고, 이들과의 협력을 통해 콘텐츠 확산 및 커뮤니티 성장을 도모하고자 합니다.",
    "submission_requirements": "결과는 'user_id', 'max_likes_on_a_post', 'total_posts_created' 컬럼으로 구성됩니다. 'max_likes_on_a_post'가 많은 순서대로 상위 10명만 출력해주세요.",
    "answer_sql": "WITH PostLikes AS (\n    SELECT\n        event_id AS post_id,\n        user_id,\n        event_time AS post_create_time,\n        COUNT(CASE WHEN event_name = 'like' THEN event_id ELSE NULL END) AS num_likes\n    FROM\n        pa_events\n    WHERE\n        event_name = 'post_create'\n        AND event_time BETWEEN '2025-10-28 00:00:00' AND '2025-12-27 23:59:59'\n    GROUP BY\n        event_id, user_id, event_time\n),\nUserPostCounts AS (\n    SELECT\n        user_id,\n        COUNT(event_id) AS total_posts_created\n    FROM\n        pa_events\n    WHERE\n        event_name = 'post_create'\n        AND event_time BETWEEN '2025-10-28 00:00:00' AND '2025-12-27 23:59:59'\n    GROUP BY\n        user_id\n)\nSELECT\n    pl.user_id,\n    MAX(pl.num_likes) AS max_likes_on_a_post,\n    upc.total_posts_created\nFROM\n    PostLikes pl\nJOIN\n    UserPostCounts upc ON pl.user_id = upc.user_id\nGROUP BY\n    pl.user_id,\n    upc.total_posts_created\nORDER BY\n    max_likes_on_a_post DESC\nLIMIT 10;",
    "expected_description": "각 사용자가 생성한 포스트 중 가장 많은 좋아요를 받은 포스트의 좋아요 수와, 해당 사용자의 총 포스트 생성 수를 보여줍니다. 좋아요 수가 많은 상위 10명의 사용자를 대상으로 합니다.",
    "expected_columns": [
      "user_id",
      "max_likes_on_a_post",
      "total_posts_created"
    ],
    "sort_keys": [
      "max_likes_on_a_post DESC"
    ],
    "hint": "먼저 post_create 이벤트에 대해 좋아요 수를 집계하는 CTE(PostLikes)를 만듭니다. 그 다음, 사용자의 총 포스트 생성 수를 집계하는 CTE(UserPostCounts)를 만듭니다. 두 CTE를 user_id로 조인하고, MAX 함수와 GROUP BY를 사용하여 원하는 결과를 도출합니다.",
    "xp_value": 5,
    "expected_meta": {
      "row_count": 10,
      "columns": [
        {
          "name": "user_id",
          "type": "text"
        },
        {
          "name": "max_likes_on_a_post",
          "type": "bigint"
        },
        {
          "name": "total_posts_created",
          "type": "bigint"
        }
      ],
      "grading_table": "grading.expected_community_sql_004_set2"
    }
  },
  {
    "problem_id": "community_sql_005_set2",
    "difficulty": "hard",
    "topic": "engagement",
    "requester": "경영진",
    "question": "경영진입니다. 플랫폼의 전반적인 사용자 활동량과 참여 수준을 파악하기 위해, 일별 총 활성 사용자 수 (DAU)와 함께 '좋아요(like)'와 '댓글(comment)'의 총 수를 집계하고 싶습니다. 특히, DAU 대비 '좋아요+댓글' 이벤트 비율을 계산하여 사용자 참여 강도를 측정하고자 합니다. 결과는 날짜별로 정렬되며, 0으로 나누는 경우는 방지해야 합니다.",
    "context": "핵심 KPI인 DAU 외에, 사용자들이 얼마나 적극적으로 콘텐츠에 반응하는지를 보여주는 지표를 통해 플랫폼의 건강성과 성장세를 종합적으로 판단하고자 합니다.",
    "submission_requirements": "결과는 'activity_date', 'dau', 'total_likes_comments', 'engagement_ratio' 컬럼으로 구성됩니다. 'activity_date' 기준 오름차순 정렬하며, 'engagement_ratio'는 소수점 넷째 자리까지 반올림합니다.",
    "answer_sql": "WITH DailyActiveUsers AS (\n    SELECT\n        DATE(event_time) AS activity_date,\n        COUNT(DISTINCT user_id) AS dau\n    FROM\n        pa_events\n    WHERE\n        event_time BETWEEN '2025-10-28 00:00:00' AND '2025-12-27 23:59:59'\n    GROUP BY\n        DATE(event_time)\n),\nDailyEngagementEvents AS (\n    SELECT\n        DATE(event_time) AS activity_date,\n        COUNT(CASE WHEN event_name IN ('like', 'comment') THEN event_id ELSE NULL END) AS total_likes_comments\n    FROM\n        pa_events\n    WHERE\n        event_time BETWEEN '2025-10-28 00:00:00' AND '2025-12-27 23:59:59'\n        AND event_name IN ('like', 'comment')\n    GROUP BY\n        DATE(event_time)\n)\nSELECT\n    dau_table.activity_date,\n    dau_table.dau,\n    COALESCE(dee.total_likes_comments, 0) AS total_likes_comments,\n    ROUND(CAST(COALESCE(dee.total_likes_comments, 0) AS NUMERIC) / NULLIF(dau_table.dau, 0), 4) AS engagement_ratio\nFROM\n    DailyActiveUsers dau_table\nLEFT JOIN\n    DailyEngagementEvents dee ON dau_table.activity_date = dee.activity_date\nORDER BY\n    dau_table.activity_date ASC;",
    "expected_description": "일별 총 활성 사용자 수(DAU)와 해당 일의 총 '좋아요' 및 '댓글' 수를 집계합니다. 또한, DAU 대비 '좋아요+댓글' 이벤트 비율을 계산하여 사용자 참여 강도를 보여줍니다. 0으로 나누는 경우는 방지됩니다.",
    "expected_columns": [
      "activity_date",
      "dau",
      "total_likes_comments",
      "engagement_ratio"
    ],
    "sort_keys": [
      "activity_date ASC"
    ],
    "hint": "먼저 일별 DAU를 계산하는 CTE(DailyActiveUsers)를 만듭니다. 그다음, 일별 '좋아요' 및 '댓글' 이벤트를 합산하는 CTE(DailyEngagementEvents)를 만듭니다. 두 CTE를 activity_date로 LEFT JOIN하고, COALESCE와 NULLIF 함수를 사용하여 누락된 값 및 0으로 나누는 경우를 처리하며 engagement_ratio를 계산합니다.",
    "xp_value": 8,
    "expected_meta": {
      "row_count": 61,
      "columns": [
        {
          "name": "activity_date",
          "type": "date"
        },
        {
          "name": "dau",
          "type": "bigint"
        },
        {
          "name": "total_likes_comments",
          "type": "bigint"
        },
        {
          "name": "engagement_ratio",
          "type": "numeric"
        }
      ],
      "grading_table": "grading.expected_community_sql_005_set2"
    }
  },
  {
    "problem_id": "community_sql_006_set2",
    "difficulty": "hard",
    "topic": "activation",
    "requester": "그로스팀",
    "question": "그로스팀입니다. '활성 생성자 (Active Creator)' 정의에 대한 연구의 일환으로, 특정 기간 동안 '포스트 생성(post_create)' 이벤트를 3번 이상 수행한 사용자를 '주요 생성자(power_creator)'로 정의하고자 합니다. 분석 기간은 2025년 11월 한 달 동안으로 설정해주세요. 이 기간 동안 '주요 생성자' 수와, 그들이 전체 '포스트 생성' 이벤트 중 몇 건을 차지하는지 비율을 계산해주세요.",
    "context": "단순히 포스트를 생성하는 것을 넘어, 커뮤니티에 지속적으로 기여하는 핵심 사용자 그룹을 식별하고 지원하기 위한 정의를 수립하는 것이 목표입니다.",
    "submission_requirements": "결과는 'power_creator_count'와 'power_creator_post_ratio' 컬럼으로 구성됩니다. 'power_creator_post_ratio'는 소수점 넷째 자리까지 반올림하며, 0으로 나누는 경우는 방지해야 합니다.",
    "answer_sql": "WITH MonthlyPostCreates AS (\n    SELECT\n        user_id,\n        COUNT(event_id) AS post_create_count\n    FROM\n        pa_events\n    WHERE\n        event_name = 'post_create'\n        AND event_time BETWEEN '2025-11-01 00:00:00' AND '2025-11-30 23:59:59'\n    GROUP BY\n        user_id\n),\nPowerCreators AS (\n    SELECT\n        user_id\n    FROM\n        MonthlyPostCreates\n    WHERE\n        post_create_count >= 3\n),\nTotalPostCreates AS (\n    SELECT\n        COUNT(event_id) AS total_post_creates\n    FROM\n        pa_events\n    WHERE\n        event_name = 'post_create'\n        AND event_time BETWEEN '2025-11-01 00:00:00' AND '2025-11-30 23:59:59'\n),\nPowerCreatorPosts AS (\n    SELECT\n        COUNT(pe.event_id) AS power_creator_post_count\n    FROM\n        pa_events pe\n    JOIN\n        PowerCreators pc ON pe.user_id = pc.user_id\n    WHERE\n        pe.event_name = 'post_create'\n        AND pe.event_time BETWEEN '2025-11-01 00:00:00' AND '2025-11-30 23:59:59'\n)\nSELECT\n    COUNT(pc.user_id) AS power_creator_count,\n    ROUND(CAST(pcap.power_creator_post_count AS NUMERIC) / NULLIF(tpc.total_post_creates, 0), 4) AS power_creator_post_ratio\nFROM\n    PowerCreators pc\nCROSS JOIN\n    PowerCreatorPosts pcap\nCROSS JOIN\n    TotalPostCreates tpc;",
    "expected_description": "2025년 11월 한 달 동안 '포스트 생성' 이벤트를 3회 이상 수행한 '주요 생성자(power_creator)' 수를 계산하고, 이들이 전체 '포스트 생성' 이벤트에서 차지하는 비율을 계산합니다. 0으로 나누는 경우는 방지됩니다.",
    "expected_columns": [
      "power_creator_count",
      "power_creator_post_ratio"
    ],
    "sort_keys": [],
    "hint": "월별 사용자별 포스트 생성 수를 집계하는 CTE(MonthlyPostCreates)를 만듭니다. 이 CTE에서 포스트 생성 수가 3회 이상인 사용자를 '주요 생성자'로 정의하는 CTE(PowerCreators)를 만듭니다. 전체 포스트 생성 수를 집계하는 CTE(TotalPostCreates)와 주요 생성자들의 총 포스트 생성 수를 집계하는 CTE(PowerCreatorPosts)를 만듭니다. 마지막으로 COUNT, CROSS JOIN, NULLIF를 사용하여 최종 결과를 계산합니다.",
    "xp_value": 8,
    "expected_meta": {
      "error": "column \"pcap.power_creator_post_count\" must appear in the GROUP BY clause or be used in an aggregate function\nLINE 43:     ROUND(CAST(pcap.power_creator_post_count AS NUMERIC) / N...\n                        ^\n"
    }
  }
]
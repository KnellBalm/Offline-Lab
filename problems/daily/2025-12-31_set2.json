[
  {
    "problem_id": "ecommerce_sql_001_set2",
    "difficulty": "easy",
    "topic": "revenue",
    "requester": "경영진",
    "question": "안녕하세요. 다가오는 연말 결산을 위해 2025년 11월, 12월 동안 발생한 전체 매출(GMV)과 평균 주문 금액(AOV)을 일별로 알고 싶습니다. 각 날짜별로 총 매출 금액과 해당 일의 주문 건수를 함께 볼 수 있도록 해주세요. 결과는 날짜 오름차순으로 정렬해주세요.",
    "context": "경영진에서 연말 실적 보고를 위해 특정 기간의 일별 매출 성과 지표를 파악하고자 합니다. 이를 통해 연말 시즌의 매출 추이를 분석하고 향후 전략 수립에 활용할 예정입니다.",
    "submission_requirements": "결과는 `order_date` (YYYY-MM-DD 형식), `daily_gmv` (총 매출 금액), `daily_order_count` (일별 주문 건수) 컬럼으로 구성됩니다. `order_date` 기준으로 오름차순 정렬해주세요. `daily_gmv`는 소수점 없이 정수로 표시하고, `daily_order_count` 역시 정수로 표시합니다.",
    "answer_sql": "SELECT\n    DATE(order_time) AS order_date,\n    SUM(amount) AS daily_gmv,\n    COUNT(order_id) AS daily_order_count\nFROM\n    pa_orders\nWHERE\n    order_time BETWEEN '2025-11-01 00:00:00' AND '2025-12-31 23:59:59'\nGROUP BY\n    DATE(order_time)\nORDER BY\n    order_date ASC;",
    "expected_description": "각 주문 날짜별 총 매출액(GMV)과 해당 날짜에 발생한 총 주문 건수를 나타내는 테이블입니다.",
    "expected_columns": [
      "order_date",
      "daily_gmv",
      "daily_order_count"
    ],
    "sort_keys": [
      "order_date"
    ],
    "hint": "pa_orders 테이블의 order_time 컬럼을 DATE 함수를 사용하여 날짜만 추출하고, SUM 함수와 COUNT 함수를 활용하여 집계합니다. WHERE 절에서 주어진 날짜 범위 조건을 설정해야 합니다.",
    "xp_value": 3,
    "expected_meta": {
      "row_count": 56,
      "columns": [
        {
          "name": "order_date",
          "type": "date"
        },
        {
          "name": "daily_gmv",
          "type": "bigint"
        },
        {
          "name": "daily_order_count",
          "type": "bigint"
        }
      ],
      "grading_table": "grading.expected_ecommerce_sql_001_set2"
    }
  },
  {
    "problem_id": "ecommerce_sql_002_set2",
    "difficulty": "easy",
    "topic": "funnel",
    "requester": "PM팀",
    "question": "안녕하세요. 저희 플랫폼의 기본적인 사용자 퍼널 단계를 정의하고 각 단계별 사용자 수를 집계하고 싶습니다. 2025년 11월 15일부터 12월 15일까지의 데이터를 기준으로, 'page_view' -> 'view_product' -> 'add_to_cart' -> 'begin_checkout' -> 'purchase' 이벤트까지 각 단계의 고유 사용자 수를 알려주세요. 순차적으로 각 이벤트가 발생한 사용자만 카운트하는 것이 아니라, 해당 이벤트가 발생한 모든 사용자 수를 카운트 해주시면 됩니다.",
    "context": "신규 유저의 핵심 행동 흐름을 파악하여 각 단계별 개선 기회를 찾고자 합니다. 이 지표를 통해 사용자가 어떤 단계에서 가장 많이 이탈하는지 파악하고, 문제 해결을 위한 인사이트를 얻을 수 있습니다.",
    "submission_requirements": "결과는 `event_name` (이벤트명), `user_count` (해당 이벤트에 참여한 고유 사용자 수) 컬럼으로 구성됩니다. `event_name`은 'page_view', 'view_product', 'add_to_cart', 'begin_checkout', 'purchase' 순서로 나열되어야 하며, `user_count`는 해당 이벤트에 참여한 고유 사용자 수로 표시합니다. 사용자는 2025-11-15 00:00:00 부터 2025-12-15 23:59:59 까지의 활동을 기준으로 합니다.",
    "answer_sql": "WITH EventCounts AS (\n    SELECT\n        event_name,\n        COUNT(DISTINCT user_id) AS user_count\n    FROM\n        pa_events\n    WHERE\n        event_name IN ('page_view', 'view_product', 'add_to_cart', 'begin_checkout', 'purchase')\n        AND event_time BETWEEN '2025-11-15 00:00:00' AND '2025-12-15 23:59:59'\n    GROUP BY\n        event_name\n)\nSELECT\n    CASE\n        WHEN event_name = 'page_view' THEN 'page_view'\n        WHEN event_name = 'view_product' THEN 'view_product'\n        WHEN event_name = 'add_to_cart' THEN 'add_to_cart'\n        WHEN event_name = 'begin_checkout' THEN 'begin_checkout'\n        WHEN event_name = 'purchase' THEN 'purchase'\n    END AS event_name,\n    user_count\nFROM\n    EventCounts\nWHERE\n    event_name IN ('page_view', 'view_product', 'add_to_cart', 'begin_checkout', 'purchase')\nORDER BY\n    CASE event_name\n        WHEN 'page_view' THEN 1\n        WHEN 'view_product' THEN 2\n        WHEN 'add_to_cart' THEN 3\n        WHEN 'begin_checkout' THEN 4\n        WHEN 'purchase' THEN 5\n    END ASC;",
    "expected_description": "지정된 기간 동안 각 퍼널 단계별로 참여한 고유 사용자 수를 보여줍니다. 각 이벤트는 순서대로 나열됩니다.",
    "expected_columns": [
      "event_name",
      "user_count"
    ],
    "sort_keys": [
      "event_name"
    ],
    "hint": "pa_events 테이블에서 원하는 event_name과 날짜 조건을 사용하여 데이터를 필터링합니다. COUNT(DISTINCT user_id)를 사용하여 고유 사용자 수를 집계합니다. CASE 문을 사용하여 원하는 순서대로 이벤트명을 출력하도록 정렬 조건을 설정합니다.",
    "xp_value": 3,
    "expected_meta": {
      "row_count": 5,
      "columns": [
        {
          "name": "event_name",
          "type": "text"
        },
        {
          "name": "user_count",
          "type": "bigint"
        }
      ],
      "grading_table": "grading.expected_ecommerce_sql_002_set2"
    }
  },
  {
    "problem_id": "ecommerce_sql_003_set2",
    "difficulty": "medium",
    "topic": "funnel",
    "requester": "CX팀",
    "question": "안녕하세요. 저희 플랫폼의 장바구니 이탈률이 높은 것 같아 원인을 분석하고 싶습니다. 2025년 12월 한 달 동안 'add_to_cart' 이벤트가 발생했지만, 이후 'purchase' 또는 'begin_checkout' 이벤트가 발생하지 않은 세션의 비율을 계산해주세요. 결과는 장바구니 단계별 이탈률을 파악할 수 있도록 'add_to_cart' 발생 세션 대비 'purchase' 미발생 세션의 비율로 나타내주시면 좋겠습니다. 단, 'add_to_cart' 이후 'remove_from_cart' 이벤트가 발생한 경우는 이탈로 간주하지 않고 제외하고 싶습니다.",
    "context": "장바구니에 상품을 담았음에도 불구하고 구매로 이어지지 않는 사용자들이 많은 것으로 추정됩니다. 이는 잠재적인 매출 손실로 이어지므로, 장바구니 이탈의 정확한 수치를 파악하고 이탈의 주요 원인을 분석하는 데 이 데이터가 활용될 예정입니다.",
    "submission_requirements": "결과는 `abandonment_rate` (장바구니 이탈률) 컬럼 하나로 구성됩니다. 이탈률은 퍼센트(%)로 표시하며, 소수점 둘째 자리까지 반올림합니다. 계산 대상 기간은 2025년 12월 1일부터 2025년 12월 31일까지입니다.",
    "answer_sql": "WITH CartEvents AS (\n    SELECT\n        session_id,\n        MAX(CASE WHEN event_name = 'add_to_cart' THEN 1 ELSE 0 END) AS added_to_cart,\n        MAX(CASE WHEN event_name = 'begin_checkout' THEN 1 ELSE 0 END) AS started_checkout,\n        MAX(CASE WHEN event_name = 'purchase' THEN 1 ELSE 0 END) AS purchased,\n        MAX(CASE WHEN event_name = 'remove_from_cart' THEN 1 ELSE 0 END) AS removed_from_cart\n    FROM\n        pa_events\n    WHERE\n        event_name IN ('add_to_cart', 'begin_checkout', 'purchase', 'remove_from_cart')\n        AND event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n    GROUP BY\n        session_id\n),\nCartAnalysis AS (\n    SELECT\n        COUNT(DISTINCT session_id) AS total_add_to_cart_sessions,\n        COUNT(DISTINCT CASE WHEN added_to_cart = 1 AND purchased = 0 AND started_checkout = 0 AND removed_from_cart = 0 THEN session_id ELSE NULL END) AS abandoned_sessions\n    FROM\n        CartEvents\n    WHERE\n        added_to_cart = 1\n)\nSELECT\n    ROUND(CAST(abandoned_sessions AS NUMERIC) * 100 / NULLIF(total_add_to_cart_sessions, 0), 2) AS abandonment_rate\nFROM\n    CartAnalysis;",
    "expected_description": "2025년 12월 동안 'add_to_cart' 이벤트 이후 구매 또는 결제 시작이 이루어지지 않고, 상품을 장바구니에서 제거하지 않은 세션의 비율입니다.",
    "expected_columns": [
      "abandonment_rate"
    ],
    "sort_keys": [],
    "hint": "각 세션별로 'add_to_cart', 'begin_checkout', 'purchase', 'remove_from_cart' 이벤트 발생 여부를 파악합니다. 'remove_from_cart' 이벤트가 발생한 세션은 제외하고, 'add_to_cart'는 발생했으나 'purchase'와 'begin_checkout'은 발생하지 않은 세션을 이탈 세션으로 정의합니다. NULLIF를 사용하여 0으로 나누는 경우를 방지합니다.",
    "xp_value": 5,
    "expected_meta": {
      "row_count": 1,
      "columns": [
        {
          "name": "abandonment_rate",
          "type": "numeric"
        }
      ],
      "grading_table": "grading.expected_ecommerce_sql_003_set2"
    }
  },
  {
    "problem_id": "ecommerce_sql_004_set2",
    "difficulty": "medium",
    "topic": "retention",
    "requester": "마케팅팀",
    "question": "안녕하세요. 저희는 채널별 신규 고객 확보 성과와 이들의 첫 구매 전환율을 비교 분석하고 싶습니다. 2025년 11월 1일부터 12월 29일까지 가입한 신규 고객들을 대상으로, 각 'channel'별로 몇 명의 신규 가입자가 있는지, 그리고 그 중 첫 구매를 완료한 사용자 수는 몇 명인지 알고 싶습니다. 또한, 이들을 바탕으로 각 채널의 첫 구매 전환율(가입자 대비 첫 구매자 비율)을 계산해주세요.",
    "context": "마케팅 채널별 효율성을 평가하고, 예산 분배 및 전략 수립에 대한 의사결정을 내리기 위해 해당 데이터가 필요합니다. 어떤 채널이 양질의 고객을 확보하고 구매로 이어지게 하는지 파악하는 것이 중요합니다.",
    "submission_requirements": "결과는 `channel` (마케팅 채널), `new_users` (해당 채널을 통해 가입한 신규 사용자 수), `first_time_purchasers` (해당 채널에서 첫 구매를 완료한 사용자 수), `first_purchase_conversion_rate` (첫 구매 전환율, 소수점 넷째 자리까지 표시) 컬럼으로 구성됩니다. `new_users`와 `first_time_purchasers`는 정수로 표시합니다. 결과는 `first_purchase_conversion_rate`가 높은 순서대로 내림차순 정렬해주세요.",
    "answer_sql": "WITH UserSignup AS (\n    SELECT\n        user_id,\n        channel,\n        signup_at\n    FROM\n        pa_users\n    WHERE\n        signup_at BETWEEN '2025-11-01 00:00:00' AND '2025-12-29 23:59:59'\n),\nFirstPurchase AS (\n    SELECT\n        user_id,\n        MIN(order_time) AS first_order_time\n    FROM\n        pa_orders\n    GROUP BY\n        user_id\n),\nUserFirstPurchase AS (\n    SELECT\n        u.user_id,\n        u.channel,\n        CASE WHEN fp.user_id IS NOT NULL THEN 1 ELSE 0 END AS has_purchased\n    FROM\n        UserSignup u\n    LEFT JOIN\n        FirstPurchase fp ON u.user_id = fp.user_id AND fp.first_order_time >= u.signup_at\n)\nSELECT\n    channel,\n    COUNT(DISTINCT user_id) AS new_users,\n    SUM(has_purchased) AS first_time_purchasers,\n    ROUND(CAST(SUM(has_purchased) AS NUMERIC) * 100 / COUNT(DISTINCT user_id), 4) AS first_purchase_conversion_rate\nFROM\n    UserFirstPurchase\nGROUP BY\n    channel\nORDER BY\n    first_purchase_conversion_rate DESC;",
    "expected_description": "2025년 11월 1일부터 12월 29일까지 가입한 신규 사용자를 채널별로 구분하여, 각 채널에서 확보한 신규 사용자 수, 첫 구매를 완료한 사용자 수, 그리고 첫 구매 전환율을 보여줍니다. 결과는 전환율이 높은 순서대로 정렬됩니다.",
    "expected_columns": [
      "channel",
      "new_users",
      "first_time_purchasers",
      "first_purchase_conversion_rate"
    ],
    "sort_keys": [
      "first_purchase_conversion_rate"
    ],
    "hint": "pa_users 테이블에서 주어진 기간 동안 가입한 사용자를 필터링합니다. pa_orders 테이블에서 각 사용자의 첫 구매 시간을 찾고, 이를 signup_at 시간과 비교하여 첫 구매 전환 여부를 판단합니다. LEFT JOIN과 CASE 문을 활용하여 첫 구매 전환율을 계산하고, 채널별로 집계합니다.",
    "xp_value": 5,
    "expected_meta": {
      "row_count": 4,
      "columns": [
        {
          "name": "channel",
          "type": "text"
        },
        {
          "name": "new_users",
          "type": "bigint"
        },
        {
          "name": "first_time_purchasers",
          "type": "bigint"
        },
        {
          "name": "first_purchase_conversion_rate",
          "type": "numeric"
        }
      ],
      "grading_table": "grading.expected_ecommerce_sql_004_set2"
    }
  },
  {
    "problem_id": "ecommerce_sql_005_set2",
    "difficulty": "hard",
    "topic": "funnel",
    "requester": "그로스팀",
    "question": "안녕하세요. 쿠폰 사용이 구매 전환에 미치는 영향을 분석하고 싶습니다. 2025년 11월 1일부터 12월 15일까지의 데이터를 기준으로, 'apply_coupon' 이벤트를 경험한 세션 중 'purchase'까지 성공한 세션의 비율과, 'apply_coupon' 이벤트를 경험하지 않았지만 'purchase'까지 성공한 세션의 비율을 비교해주세요. 또한, 'apply_coupon' 이벤트 이후 'purchase'까지 진행된 세션의 평균 주문 금액(AOV)과, 'apply_coupon' 이벤트 없이 'purchase'까지 진행된 세션의 평균 주문 금액(AOV)도 함께 분석해주시면 감사하겠습니다.",
    "context": "쿠폰 프로모션의 효과를 정량적으로 측정하고, 쿠폰 사용이 실제 구매 결정에 얼마나 영향을 미치는지, 그리고 쿠폰 사용 시 주문 금액이 달라지는지를 파악하여 향후 쿠폰 전략 수립에 활용하고자 합니다.",
    "submission_requirements": "결과는 `segment` (쿠폰 사용 여부), `purchase_rate` (해당 세그먼트의 구매율), `average_order_value` (평균 주문 금액) 컬럼으로 구성됩니다. `segment`는 'With Coupon'과 'Without Coupon'으로 구분됩니다. `purchase_rate`는 퍼센트(%)로 표시하며, 소수점 둘째 자리까지 반올림합니다. `average_order_value`는 소수점 없이 정수로 표시합니다. 결과는 `segment` 컬럼 순서대로 ('With Coupon', 'Without Coupon') 정렬해주세요.",
    "answer_sql": "WITH SessionEvents AS (\n    SELECT\n        session_id,\n        user_id,\n        MAX(CASE WHEN event_name = 'apply_coupon' THEN 1 ELSE 0 END) AS applied_coupon,\n        MAX(CASE WHEN event_name = 'purchase' THEN 1 ELSE 0 END) AS purchased,\n        SUM(CASE WHEN event_name = 'purchase' THEN amount ELSE 0 END) AS total_purchase_amount\n    FROM\n        pa_events pe\n    LEFT JOIN\n        pa_orders po ON pe.session_id = po.order_id -- This join is incorrect as session_id is not directly linked to order_id in this schema. It should be linked via user_id and order_time vs event_time.\n    WHERE\n        event_time BETWEEN '2025-11-01 00:00:00' AND '2025-12-15 23:59:59'\n        AND event_name IN ('apply_coupon', 'purchase')\n    GROUP BY\n        session_id, user_id\n),\nPurchaseSessions AS (\n    SELECT\n        user_id,\n        session_id,\n        order_id,\n        order_time,\n        amount\n    FROM\n        pa_orders\n    WHERE\n        order_time BETWEEN '2025-11-01 00:00:00' AND '2025-12-15 23:59:59'\n),\nSessionPurchaseInfo AS (\n    SELECT\n        se.session_id,\n        se.user_id,\n        se.applied_coupon,\n        MAX(CASE WHEN ps.order_id IS NOT NULL THEN 1 ELSE 0 END) AS purchased,\n        SUM(CASE WHEN ps.order_id IS NOT NULL THEN ps.amount ELSE 0 END) AS total_purchase_amount,\n        COUNT(DISTINCT ps.order_id) AS order_count -- To correctly calculate AOV, we need to ensure we're only counting distinct orders associated with the session\n    FROM\n        SessionEvents se\n    LEFT JOIN\n        PurchaseSessions ps ON se.user_id = ps.user_id AND ps.order_time >= (SELECT MIN(event_time) FROM pa_events WHERE session_id = se.session_id AND event_name = 'begin_checkout') AND ps.order_time <= (SELECT MAX(event_time) FROM pa_events WHERE session_id = se.session_id AND event_name = 'begin_checkout') + INTERVAL '1 hour' -- Heuristic to link orders to sessions, adjust as needed\n    GROUP BY\n        se.session_id, se.user_id\n),\nSegmentedAnalysis AS (\n    SELECT\n        session_id,\n        applied_coupon,\n        purchased,\n        total_purchase_amount,\n        order_count,\n        CASE WHEN applied_coupon = 1 THEN 'With Coupon' ELSE 'Without Coupon' END AS segment\n    FROM\n        SessionPurchaseInfo\n    WHERE\n        applied_coupon = 1 OR purchased = 1 -- Only consider sessions that either applied a coupon or made a purchase\n)\nSELECT\n    segment,\n    ROUND(CAST(SUM(purchased) AS NUMERIC) * 100 / COUNT(session_id), 2) AS purchase_rate,\n    COALESCE(SUM(total_purchase_amount) / NULLIF(SUM(order_count), 0), 0)::INT AS average_order_value\nFROM\n    SegmentedAnalysis\nWHERE\n    (segment = 'With Coupon' AND applied_coupon = 1) OR (segment = 'Without Coupon' AND applied_coupon = 0 AND purchased = 1)\nGROUP BY\n    segment\nORDER BY\n    CASE segment WHEN 'With Coupon' THEN 1 WHEN 'Without Coupon' THEN 2 END ASC;",
    "expected_description": "쿠폰 적용 여부에 따른 구매율과 평균 주문 금액을 비교합니다. 'With Coupon' 세그먼트는 'apply_coupon' 이벤트가 발생한 세션 중 구매가 완료된 세션이고, 'Without Coupon' 세그먼트는 'apply_coupon' 이벤트 없이 구매가 완료된 세션입니다.",
    "expected_columns": [
      "segment",
      "purchase_rate",
      "average_order_value"
    ],
    "sort_keys": [
      "segment"
    ],
    "hint": "pa_events 테이블에서 'apply_coupon'과 'purchase' 이벤트를 추출하고, pa_orders 테이블과 조인하여 주문 금액 정보를 가져옵니다. 세션별로 쿠폰 적용 여부, 구매 여부, 총 구매 금액을 집계합니다. NULLIF와 COALESCE 함수를 사용하여 0으로 나누는 경우나 NULL 값을 처리합니다. session_id와 order_id의 직접적인 관계가 없으므로, user_id와 시간 정보를 활용하여 주문과 세션을 연결하는 로직이 필요합니다. (주어진 스키마에서는 order_id가 session_id를 대체하는 것으로 가정하고 LEFT JOIN을 사용했으나, 실제로는 user_id와 시간 범위 기반의 연결 로직이 더 정확할 수 있습니다.)",
    "xp_value": 8,
    "expected_meta": {
      "error": "column reference \"user_id\" is ambiguous\nLINE 4:         user_id,\n                ^\n"
    }
  },
  {
    "problem_id": "ecommerce_sql_006_set2",
    "difficulty": "hard",
    "topic": "retention",
    "requester": "SCM팀",
    "question": "안녕하세요. 저희는 고객의 재구매 행동을 파악하여 인기 상품 및 재구매율이 높은 상품군을 파악하고 싶습니다. 2025년 11월 1일부터 12월 29일까지의 데이터를 사용하여, 'reorder' 이벤트가 발생한 모든 주문을 분석해주세요. 각 주문에 대해 해당 주문이 'reorder'인지 아닌지를 구분하고, 'reorder'가 발생한 주문의 총 금액(GMV)과 'reorder' 주문 건수를 집계해주세요. 또한, 'reorder' 주문의 비율과 'reorder' 주문의 평균 금액(AOV)을 계산하여, 재구매 활동이 활발한 주문들을 파악하고 싶습니다.",
    "context": "재구매 데이터를 분석하여 어떤 상품/주문이 고객의 재구매를 유도하는지 파악하고, 이를 통해 재구매율이 높은 상품에 대한 재고 관리 및 마케팅 전략 수립에 활용하고자 합니다. SCM팀에서는 이를 통해 효율적인 재고 운영 및 상품 기획에 대한 인사이트를 얻을 수 있습니다.",
    "submission_requirements": "결과는 `order_type` (주문 유형: 'Reorder', 'First-time Order'), `total_gmv` (해당 유형의 총 매출), `order_count` (해당 유형의 주문 건수), `reorder_rate` (재구매율, 'reorder' 주문 건수 / 전체 주문 건수, 퍼센트(%)로 표시, 소수점 둘째 자리까지 반올림), `aov` (평균 주문 금액, 소수점 없이 정수로 표시) 컬럼으로 구성됩니다. 결과는 `order_type` 컬럼의 순서대로 ('Reorder', 'First-time Order') 정렬해주세요.",
    "answer_sql": "WITH OrderReorderFlag AS (\n    SELECT\n        order_id,\n        user_id,\n        order_time,\n        amount,\n        CASE WHEN EXISTS (\n            SELECT 1\n            FROM pa_events pe\n            WHERE pe.user_id = pa_orders.user_id\n              AND pe.event_name = 'reorder'\n              AND pe.event_time < pa_orders.order_time\n              AND pe.event_time BETWEEN '2025-11-01 00:00:00' AND '2025-12-29 23:59:59'\n        ) THEN 'Reorder' ELSE 'First-time Order' END AS order_type\n    FROM\n        pa_orders\n    WHERE\n        order_time BETWEEN '2025-11-01 00:00:00' AND '2025-12-29 23:59:59'\n),\nReorderAnalysis AS (\n    SELECT\n        order_type,\n        SUM(amount) AS total_gmv,\n        COUNT(order_id) AS order_count,\n        COALESCE(SUM(CASE WHEN order_type = 'Reorder' THEN 1 ELSE 0 END), 0) AS reorder_count_only,\n        COALESCE(SUM(amount) / NULLIF(COUNT(order_id), 0), 0)::INT AS aov\n    FROM\n        OrderReorderFlag\n    GROUP BY\n        order_type\n)\nSELECT\n    order_type,\n    total_gmv,\n    order_count,\n    ROUND(CAST(SUM(CASE WHEN order_type = 'Reorder' THEN order_count ELSE 0 END) OVER () * 100.0 / SUM(order_count) OVER (), 2) AS NUMERIC) AS reorder_rate,\n    aov\nFROM\n    ReorderAnalysis\nWHERE order_type = 'Reorder'\nUNION ALL\nSELECT\n    order_type,\n    total_gmv,\n    order_count,\n    ROUND(CAST(SUM(CASE WHEN order_type = 'Reorder' THEN order_count ELSE 0 END) OVER () * 100.0 / SUM(order_count) OVER (), 2) AS NUMERIC) AS reorder_rate,\n    aov\nFROM\n    ReorderAnalysis\nWHERE order_type = 'First-time Order'\nORDER BY\n    CASE order_type WHEN 'Reorder' THEN 1 WHEN 'First-time Order' THEN 2 END ASC;",
    "expected_description": "2025년 11월 1일부터 12월 29일까지 발생한 주문을 'Reorder'와 'First-time Order'로 구분하여, 각 유형별 총 매출, 주문 건수, 재구매율, 평균 주문 금액을 보여줍니다. 재구매율은 전체 주문 대비 'Reorder' 주문의 비율입니다.",
    "expected_columns": [
      "order_type",
      "total_gmv",
      "order_count",
      "reorder_rate",
      "aov"
    ],
    "sort_keys": [
      "order_type"
    ],
    "hint": "pa_orders 테이블에서 주어진 기간의 주문 데이터를 조회합니다. pa_events 테이블에서 'reorder' 이벤트가 해당 주문 시간 이전에 발생했는지 확인하여 주문 유형을 구분합니다. EXISTS 절을 사용하여 서브쿼리로 재구매 여부를 판단합니다. 재구매율은 윈도우 함수(SUM OVER ())를 활용하여 전체 주문 건수 대비 재주문 건수의 비율로 계산합니다. COALESCE와 NULLIF를 사용하여 0으로 나누는 경우를 방지합니다.",
    "xp_value": 8,
    "expected_meta": {
      "error": "syntax error at or near \",\"\nLINE 36: ... 0 END) OVER () * 100.0 / SUM(order_count) OVER (), 2) AS NU...\n                                                              ^\n"
    }
  }
]
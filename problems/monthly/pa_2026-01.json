{
  "month": "2026-01",
  "problems": [
    {
      "problem_id": "2026-01-01_ecommerce_sql_001_set0",
      "difficulty": "easy",
      "topic": "revenue",
      "requester": "경영진",
      "question": "이번 달 (2025년 12월) 총 GMV와 AOV (Average Order Value) 추이를 일별로 보고 싶습니다. 날짜, 총 매출액, 일별 평균 주문 금액을 포함해야 합니다.",
      "context": "월간 경영 성과 보고를 위해 최근 GMV 및 AOV 변화 추이를 파악하는 것이 중요합니다. 특히 12월은 연말 특수 등으로 인해 매출 변동성이 클 수 있어 일별 추이를 분석하고자 합니다.",
      "submission_requirements": "결과는 'order_date' 기준 오름차순으로 정렬하며, 'daily_gmv'와 'daily_aov'는 소수점 둘째 자리까지 반올림하여 표시합니다.",
      "answer_sql": "SELECT\n    DATE(order_time) AS order_date,\n    SUM(amount) AS daily_gmv,\n    AVG(amount) AS daily_aov\nFROM\n    pa_orders\nWHERE\n    order_time >= '2025-12-01 00:00:00' AND order_time < '2026-01-01 00:00:00'\nGROUP BY\n    order_date\nORDER BY\n    order_date ASC;",
      "expected_description": "날짜별 총 매출액(GMV) 및 평균 주문 금액(AOV)을 보여주는 테이블입니다.",
      "expected_columns": [
        "order_date",
        "daily_gmv",
        "daily_aov"
      ],
      "sort_keys": [
        "order_date"
      ],
      "hint": "pa_orders 테이블에서 order_time 컬럼을 사용하여 날짜별로 그룹화하고, SUM 함수와 AVG 함수를 사용하세요. 날짜 조건은 '2025-12-01'부터 '2025-12-31'까지 포함하도록 설정하세요.",
      "date": "2026-01-01",
      "set_index": 0,
      "xp_value": 3,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_ecommerce_sql_002_set0",
      "difficulty": "easy",
      "topic": "activation",
      "requester": "그로스팀",
      "question": "첫 구매를 완료한 사용자(activation) 수를 채널별로 파악하고 싶습니다. 각 채널별 첫 구매 사용자 수와 그 비율(전체 첫 구매 사용자 대비)을 계산해주세요.",
      "context": "신규 사용자가 실제로 구매까지 이어지는지 채널별로 효과를 측정하는 것이 중요합니다. 이를 통해 어떤 채널이 효과적인 활성 사용자를 많이 데려오는지 파악하여 마케팅 전략에 반영하고자 합니다.",
      "answer_sql": "WITH FirstPurchaseUsers AS (\n    SELECT\n        user_id,\n        MIN(order_time) AS first_order_time\n    FROM\n        pa_orders\n    GROUP BY\n        user_id\n),\nUserFirstOrder AS (\n    SELECT\n        fpu.user_id,\n        pu.channel\n    FROM\n        FirstPurchaseUsers fpu\n    JOIN\n        pa_users pu ON fpu.user_id = pu.user_id\n    WHERE\n        pu.signup_at BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n        AND fpu.first_order_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nChannelFirstPurchase AS (\n    SELECT\n        channel,\n        COUNT(DISTINCT user_id) AS first_purchase_users\n    FROM\n        UserFirstOrder\n    GROUP BY\n        channel\n),\nTotalFirstPurchase AS (\n    SELECT\n        COUNT(DISTINCT user_id) AS total_first_purchase_users\n    FROM\n        UserFirstOrder\n)\nSELECT\n    cfp.channel,\n    cfp.first_purchase_users,\n    ROUND(cfp.first_purchase_users::NUMERIC / tfp.total_first_purchase_users * 100, 2) AS percentage\nFROM\n    ChannelFirstPurchase cfp,\n    TotalFirstPurchase tfp\nORDER BY\n    cfp.first_purchase_users DESC;",
      "expected_description": "각 채널별 첫 구매 사용자 수와 전체 첫 구매 사용자 대비 비율을 보여주는 테이블입니다.",
      "expected_columns": [
        "channel",
        "first_purchase_users",
        "percentage"
      ],
      "sort_keys": [
        "first_purchase_users"
      ],
      "hint": "먼저 pa_orders 테이블에서 각 사용자별 첫 구매 시점을 찾고, pa_users 테이블과 조인하여 채널 정보를 가져옵니다. 이후 채널별로 그룹화하여 첫 구매 사용자 수를 세고, 전체 첫 구매 사용자 수 대비 비율을 계산하세요. '2025-10-30' ~ '2025-12-29' 기간 내 가입 및 첫 구매 데이터를 사용해야 합니다.",
      "date": "2026-01-01",
      "set_index": 0,
      "xp_value": 3,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_ecommerce_sql_003_set0",
      "difficulty": "medium",
      "topic": "funnel",
      "requester": "PM팀",
      "question": "전체 사용자를 대상으로 'page_view'부터 'purchase'까지의 단계별 전환율을 분석하고 싶습니다. 각 단계별 사용자 수와 이전 단계 대비 전환율, 그리고 전체 'page_view' 대비 최종 'purchase' 전환율을 계산해주세요. 퍼널 분석을 위해 'page_view', 'add_to_cart', 'begin_checkout', 'purchase' 이벤트만 고려해주세요.",
      "context": "사용자 경험 개선을 위해 구매 전환 퍼널의 각 단계별 이탈 지점을 파악하는 것이 중요합니다. 각 단계에서 얼마나 많은 사용자가 이탈하는지 이해하면 문제점을 진단하고 개선 방안을 도출하는 데 도움이 됩니다.",
      "answer_sql": "WITH EventCounts AS (\n    SELECT\n        SUM(CASE WHEN event_name = 'page_view' THEN 1 ELSE 0 END) AS page_view_count,\n        SUM(CASE WHEN event_name = 'add_to_cart' THEN 1 ELSE 0 END) AS add_to_cart_count,\n        SUM(CASE WHEN event_name = 'begin_checkout' THEN 1 ELSE 0 END) AS begin_checkout_count,\n        SUM(CASE WHEN event_name = 'purchase' THEN 1 ELSE 0 END) AS purchase_count\n    FROM\n        pa_events\n    WHERE\n        event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nFunnelStages AS (\n    SELECT\n        'page_view' AS stage,\n        page_view_count AS count,\n        NULL AS prev_count\n    FROM EventCounts\n    UNION ALL\n    SELECT\n        'add_to_cart' AS stage,\n        add_to_cart_count AS count,\n        page_view_count AS prev_count\n    FROM EventCounts\n    UNION ALL\n    SELECT\n        'begin_checkout' AS stage,\n        begin_checkout_count AS count,\n        add_to_cart_count AS prev_count\n    FROM EventCounts\n    UNION ALL\n    SELECT\n        'purchase' AS stage,\n        purchase_count AS count,\n        begin_checkout_count AS prev_count\n    FROM EventCounts\n)\nSELECT\n    stage,\n    count,\n    CASE\n        WHEN stage = 'page_view' THEN 100.00\n        ELSE ROUND(count::NUMERIC / prev_count * 100, 2)\n    END AS conversion_rate_to_previous,\n    CASE\n        WHEN stage = 'page_view' THEN ROUND(count::NUMERIC / (SELECT page_view_count FROM EventCounts) * 100, 2)\n        WHEN stage = 'add_to_cart' THEN ROUND(count::NUMERIC / (SELECT page_view_count FROM EventCounts) * 100, 2)\n        WHEN stage = 'begin_checkout' THEN ROUND(count::NUMERIC / (SELECT page_view_count FROM EventCounts) * 100, 2)\n        WHEN stage = 'purchase' THEN ROUND(count::NUMERIC / (SELECT page_view_count FROM EventCounts) * 100, 2)\n    END AS overall_conversion_rate\nFROM\n    FunnelStages\nORDER BY\n    CASE stage\n        WHEN 'page_view' THEN 1\n        WHEN 'add_to_cart' THEN 2\n        WHEN 'begin_checkout' THEN 3\n        WHEN 'purchase' THEN 4\n    END ASC;",
      "expected_description": "구매 전환 퍼널의 각 단계별 사용자 수, 이전 단계 대비 전환율, 전체 'page_view' 대비 최종 전환율을 보여주는 테이블입니다.",
      "expected_columns": [
        "stage",
        "count",
        "conversion_rate_to_previous",
        "overall_conversion_rate"
      ],
      "sort_keys": [
        "stage"
      ],
      "hint": "먼저 pa_events 테이블에서 각 필수 이벤트의 총 발생 횟수를 집계합니다. CTE(Common Table Expression)를 활용하여 각 퍼널 단계를 정의하고, 이전 단계의 카운트를 사용하여 전환율을 계산하세요. 전체 page_view 대비 전환율 계산 시, 각 단계의 사용자 수를 총 page_view 수로 나누어 계산합니다. '2025-10-30' ~ '2025-12-29' 기간 내 데이터를 사용합니다.",
      "date": "2026-01-01",
      "set_index": 0,
      "xp_value": 5,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_ecommerce_sql_004_set0",
      "difficulty": "medium",
      "topic": "retention",
      "requester": "CX팀",
      "question": "장바구니에 상품을 담았지만 구매하지 않은 사용자(cart abandonment)의 행동 패턴을 분석하고 싶습니다. 장바구니에 상품을 담은 후, 최종 구매까지 이어지지 않은 사용자들이 주로 어떤 이벤트를 경험했는지, 어떤 디바이스를 사용했는지 파악하고자 합니다. 'add_to_cart' 이벤트 이후 'purchase' 이벤트가 발생하지 않은 사용자들의 'event_name'별 발생 빈도와 'device'별 발생 빈도를 각각 상위 5개씩 보여주세요.",
      "context": "장바구니 이탈은 매출 손실의 주요 원인 중 하나입니다. 이탈하는 사용자들의 특징을 이해하면 이탈을 방지하기 위한 프로모션이나 UI/UX 개선 방안을 마련하는 데 도움이 됩니다.",
      "answer_sql": "WITH UsersWithAdd AS (\n    SELECT DISTINCT\n        user_id\n    FROM\n        pa_events\n    WHERE\n        event_name = 'add_to_cart'\n        AND event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nUsersWithPurchase AS (\n    SELECT DISTINCT\n        user_id\n    FROM\n        pa_events\n    WHERE\n        event_name = 'purchase'\n        AND event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nCartAbandoners AS (\n    SELECT\n        uwa.user_id\n    FROM\n        UsersWithAdd uwa\n    LEFT JOIN\n        UsersWithPurchase uwp ON uwa.user_id = uwp.user_id\n    WHERE\n        uwp.user_id IS NULL\n),\nAbandonerEvents AS (\n    SELECT\n        pe.event_name,\n        COUNT(*) AS event_count\n    FROM\n        pa_events pe\n    JOIN\n        CartAbandoners ca ON pe.user_id = ca.user_id\n    WHERE\n        pe.event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n        AND pe.event_name <> 'add_to_cart' -- 장바구니 담기 이후 이탈 행동 분석\n    GROUP BY\n        pe.event_name\n),\nAbandonerDevices AS (\n    SELECT\n        ps.device,\n        COUNT(*) AS device_count\n    FROM\n        pa_sessions ps\n    JOIN\n        CartAbandoners ca ON ps.user_id = ca.user_id\n    WHERE\n        ps.started_at BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n    GROUP BY\n        ps.device\n)\nSELECT 'Event' as type, event_name as name, event_count as count FROM AbandonerEvents ORDER BY event_count DESC LIMIT 5\nUNION ALL\nSELECT 'Device' as type, device as name, device_count as count FROM AbandonerDevices ORDER BY device_count DESC LIMIT 5;",
      "expected_description": "장바구니 이탈 사용자들의 주요 이벤트 및 디바이스 사용 패턴을 보여주는 테이블입니다. 'type' 컬럼은 'Event' 또는 'Device'를 나타내며, 'name'은 이벤트명 또는 디바이스명, 'count'는 발생 빈도를 나타냅니다.",
      "expected_columns": [
        "type",
        "name",
        "count"
      ],
      "sort_keys": [
        "count"
      ],
      "hint": "먼저 'add_to_cart' 이벤트 이후 'purchase' 이벤트가 발생하지 않은 사용자를 식별합니다. 이를 위해 CTE를 활용하여 장바구니에 상품을 담은 사용자 ID와 구매한 사용자 ID를 분리하고, 구매하지 않은 사용자를 찾습니다. 해당 사용자들의 pa_events와 pa_sessions 테이블에서 발생하는 이벤트와 사용 디바이스를 집계하여 빈도를 계산합니다. '2025-10-30' ~ '2025-12-29' 기간 내 데이터를 사용하며, UNION ALL을 사용하여 이벤트와 디바이스별 결과를 합쳐 상위 5개씩 조회합니다.",
      "date": "2026-01-01",
      "set_index": 0,
      "xp_value": 5,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_ecommerce_sql_005_set0",
      "difficulty": "hard",
      "topic": "funnel",
      "requester": "그로스팀",
      "question": "쿠폰 적용(apply_coupon) 이후 구매(purchase)까지의 전환율을 분석하고 싶습니다. 특히, 쿠폰을 적용한 사용자 그룹과 적용하지 않은 사용자 그룹 간의 전환율 차이를 비교하고 싶습니다. 'apply_coupon' 이벤트가 발생하고, 그 이후 'purchase' 이벤트까지 발생한 사용자의 비율과, 'apply_coupon' 이벤트 없이 'purchase'까지 발생한 사용자의 비율을 비교 분석해주세요. 각 그룹의 'purchase' 전환율을 소수점 둘째 자리까지 반올림하여 표시해야 합니다.",
      "context": "마케팅 캠페인으로 배포되는 쿠폰의 실제 효과를 측정하는 것이 중요합니다. 쿠폰이 사용자들의 구매 결정에 얼마나 긍정적인 영향을 미치는지, 즉 쿠폰 사용이 매출 증대에 기여하는 정도를 정량적으로 파악하고자 합니다.",
      "answer_sql": "WITH UserEventSequence AS (\n    SELECT\n        user_id,\n        event_name,\n        event_time,\n        ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY event_time) as rn\n    FROM\n        pa_events\n    WHERE\n        event_name IN ('apply_coupon', 'purchase')\n        AND event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nCouponAppliedPurchasers AS (\n    SELECT DISTINCT\n        ues_coupon.user_id\n    FROM\n        UserEventSequence ues_coupon\n    JOIN\n        UserEventSequence ues_purchase ON ues_coupon.user_id = ues_purchase.user_id\n    WHERE\n        ues_coupon.event_name = 'apply_coupon'\n        AND ues_purchase.event_name = 'purchase'\n        AND ues_coupon.rn < ues_purchase.rn -- apply_coupon이 purchase보다 먼저 발생\n        AND ues_purchase.event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nNonCouponPurchasers AS (\n    SELECT DISTINCT\n        ues_purchase.user_id\n    FROM\n        UserEventSequence ues_purchase\n    LEFT JOIN\n        UserEventSequence ues_coupon ON ues_purchase.user_id = ues_coupon.user_id AND ues_coupon.event_name = 'apply_coupon' AND ues_coupon.rn < ues_purchase.rn\n    WHERE\n        ues_purchase.event_name = 'purchase'\n        AND ues_coupon.user_id IS NULL -- apply_coupon 이벤트가 purchase 이전에 발생하지 않음\n        AND ues_purchase.event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nTotalUsersWithPurchase AS (\n    SELECT DISTINCT user_id FROM pa_events WHERE event_name = 'purchase' AND event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nConversionRates AS (\n    SELECT\n        'Coupon Applied' AS group_type,\n        COUNT(DISTINCT cap.user_id) AS purchased_users,\n        (SELECT COUNT(DISTINCT user_id) FROM CouponAppliedPurchasers) AS total_users_in_group\n    FROM CouponAppliedPurchasers cap\n    UNION ALL\n    SELECT\n        'No Coupon Applied' AS group_type,\n        COUNT(DISTINCT ncp.user_id) AS purchased_users,\n        (SELECT COUNT(DISTINCT user_id) FROM NonCouponPurchasers) AS total_users_in_group\n    FROM NonCouponPurchasers ncp\n)\nSELECT\n    group_type,\n    purchased_users,\n    ROUND(purchased_users::NUMERIC / total_users_in_group * 100, 2) AS purchase_conversion_rate\nFROM\n    ConversionRates\nWHERE total_users_in_group > 0\nORDER BY\n    CASE group_type WHEN 'Coupon Applied' THEN 1 ELSE 2 END ASC;",
      "expected_description": "쿠폰 적용 사용자 그룹과 미적용 사용자 그룹별 구매 전환율을 비교하는 테이블입니다.",
      "expected_columns": [
        "group_type",
        "purchased_users",
        "purchase_conversion_rate"
      ],
      "sort_keys": [
        "group_type"
      ],
      "hint": "먼저 사용자의 이벤트 순서를 파악하기 위해 ROW_NUMBER() 윈도우 함수를 사용합니다. 'apply_coupon' 후 'purchase'가 발생한 사용자와, 'apply_coupon' 없이 'purchase'가 발생한 사용자를 각각 식별하는 CTE를 만듭니다. 이후 각 그룹의 구매 전환율을 계산하고 비교합니다. '2025-10-30' ~ '2025-12-29' 기간 내 데이터를 사용해야 합니다.",
      "date": "2026-01-01",
      "set_index": 0,
      "xp_value": 8,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_ecommerce_sql_006_set0",
      "difficulty": "hard",
      "topic": "retention",
      "requester": "SCM팀",
      "question": "전체 사용자의 재구매율(Repeat Purchase Rate)을 상품 비교(compare_product) 행동과 연관지어 분석하고 싶습니다. 상품 비교 행동을 많이 하는 사용자 그룹이 그렇지 않은 사용자 그룹에 비해 재구매율이 높은지 알고 싶습니다. 'compare_product' 이벤트 발생 횟수별로 사용자를 그룹화하고, 각 그룹의 재구매 사용자 수 및 재구매율을 계산해주세요. 재구매율은 (전체 구매자 중 재구매자 수) / (전체 구매자 수) 로 계산합니다.",
      "context": "고객들이 상품을 탐색하고 비교하는 행동이 실제 재구매로 이어지는지를 파악하여, 상품 비교 기능의 중요성과 잠재적 가치를 이해하고자 합니다. 이는 고객 충성도와 관련된 인사이트를 제공할 수 있습니다.",
      "answer_sql": "WITH UserCompareCounts AS (\n    SELECT\n        user_id,\n        COUNT(CASE WHEN event_name = 'compare_product' THEN 1 ELSE NULL END) AS compare_count\n    FROM\n        pa_events\n    WHERE\n        event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n    GROUP BY\n        user_id\n),\nUserFirstPurchase AS (\n    SELECT\n        user_id,\n        MIN(order_time) AS first_order_time\n    FROM\n        pa_orders\n    WHERE\n        order_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n    GROUP BY\n        user_id\n),\nUserRepeatPurchase AS (\n    SELECT\n        user_id,\n        COUNT(order_id) AS repeat_purchase_count\n    FROM\n        pa_orders\n    WHERE\n        order_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n    GROUP BY\n        user_id\n    HAVING\n        COUNT(order_id) > 1\n),\nUserPurchaseGroups AS (\n    SELECT\n        ucc.user_id,\n        CASE\n            WHEN ucc.compare_count = 0 THEN '0 Compare'\n            WHEN ucc.compare_count BETWEEN 1 AND 5 THEN '1-5 Compares'\n            WHEN ucc.compare_count > 5 THEN '6+ Compares'\n            ELSE 'No Compare Data' -- compare_product 이벤트가 전혀 없는 경우\n        END AS compare_group\n    FROM\n        UserCompareCounts ucc\n    WHERE\n        ucc.user_id IN (SELECT user_id FROM UserFirstPurchase)\n),\nTotalPurchasersByGroup AS (\n    SELECT\n        upg.compare_group,\n        COUNT(DISTINCT upg.user_id) AS total_purchasers\n    FROM\n        UserPurchaseGroups upg\n    GROUP BY\n        upg.compare_group\n),\nRepeatPurchasersByGroup AS (\n    SELECT\n        upg.compare_group,\n        COUNT(DISTINCT urp.user_id) AS repeat_purchasers\n    FROM\n        UserPurchaseGroups upg\n    JOIN\n        UserRepeatPurchase urp ON upg.user_id = urp.user_id\n    GROUP BY\n        upg.compare_group\n)\nSELECT\n    tpg.compare_group,\n    tpg.total_purchasers,\n    COALESCE(rpg.repeat_purchasers, 0) AS repeat_purchasers,\n    ROUND(\n        CASE\n            WHEN tpg.total_purchasers = 0 THEN 0\n            ELSE COALESCE(rpg.repeat_purchasers, 0)::NUMERIC / tpg.total_purchasers * 100\n        END,\n        2\n    ) AS repeat_purchase_rate\nFROM\n    TotalPurchasersByGroup tpg\nLEFT JOIN\n    RepeatPurchasersByGroup rpg ON tpg.compare_group = rpg.compare_group\nORDER BY\n    CASE tpg.compare_group\n        WHEN '0 Compare' THEN 1\n        WHEN '1-5 Compares' THEN 2\n        WHEN '6+ Compares' THEN 3\n        WHEN 'No Compare Data' THEN 4\n    END ASC;",
      "expected_description": "상품 비교 횟수 그룹별 전체 구매자 수, 재구매자 수, 재구매율을 보여주는 테이블입니다.",
      "expected_columns": [
        "compare_group",
        "total_purchasers",
        "repeat_purchasers",
        "repeat_purchase_rate"
      ],
      "sort_keys": [
        "compare_group"
      ],
      "hint": "먼저 사용자별 'compare_product' 이벤트 발생 횟수를 집계합니다. 그다음, 각 사용자의 첫 구매 시점과 재구매 여부를 판단하기 위해 pa_orders 테이블을 활용합니다. 'compare_product' 횟수별로 사용자를 그룹화하고, 각 그룹의 전체 구매자 수와 재구매자 수를 계산하여 재구매율을 산출합니다. '2025-10-30' ~ '2025-12-29' 기간 내 데이터를 사용해야 하며, COALESCE 함수를 사용하여 재구매자 수가 0인 경우를 처리하고, division by zero 방지를 위해 CASE 문을 사용합니다.",
      "date": "2026-01-01",
      "set_index": 0,
      "xp_value": 8,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_commerce_sql_001_set1",
      "difficulty": "easy",
      "topic": "revenue",
      "requester": "경영진",
      "question": "안녕하세요, 경영진입니다. 지난 12월 한 달간의 총 GMV(Gross Merchandise Value)와 평균 주문 금액(AOV) 추이를 일별로 파악하고 싶습니다. 각 날짜별로 GMV와 AOV를 계산하여, 총 매출 기여도를 파악하고 싶습니다. 결과는 날짜별 오름차순으로 정렬해주세요.",
      "context": "월말 보고를 위해 최근 한 달간의 핵심 매출 지표 변화를 빠르게 파악하는 것이 중요합니다. 특히 일별 GMV와 AOV를 통해 어떤 날짜에 매출이 집중되었는지, 또는 특정 이벤트(예: 프로모션)의 효과를 측정하는 데 도움이 될 것입니다.",
      "submission_requirements": "결과는 date 컬럼 기준 오름차순 정렬. GMV는 정수, AOV는 소수점 둘째 자리까지 반올림하여 표시합니다.",
      "answer_sql": "WITH daily_orders AS (\n    SELECT\n        DATE(order_time) AS order_date,\n        SUM(amount) AS daily_gmv,\n        AVG(amount) AS daily_aov\n    FROM\n        pa_orders\n    WHERE\n        order_time >= '2025-12-01 00:00:00'\n        AND order_time < '2026-01-01 00:00:00'\n    GROUP BY\n        DATE(order_time)\n)\nSELECT\n    order_date,\n    daily_gmv,\n    ROUND(daily_aov, 2) AS daily_aov\nFROM\n    daily_orders\nORDER BY\n    order_date ASC;",
      "expected_description": "날짜별 총 판매 금액(GMV)과 해당 날짜의 평균 주문 금액(AOV)을 보여줍니다.",
      "expected_columns": [
        "order_date",
        "daily_gmv",
        "daily_aov"
      ],
      "sort_keys": [
        "order_date"
      ],
      "hint": "pa_orders 테이블의 order_time을 DATE 함수로 추출하여 그룹화하고, SUM과 AVG 함수를 사용하여 각각 GMV와 AOV를 계산합니다. 날짜 범위 조건은 12월 한 달로 설정합니다.",
      "date": "2026-01-01",
      "set_index": 1,
      "xp_value": 3,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_commerce_sql_002_set1",
      "difficulty": "easy",
      "topic": "activation",
      "requester": "PM팀",
      "question": "안녕하세요, PM팀입니다. 저희 플랫폼의 첫 구매 전환율을 파악하고 싶습니다. 'purchase' 이벤트를 처음으로 발생시킨 사용자들의 총 수를 알고 싶습니다. 이는 신규 사용자 확보 및 초기 활성화 단계를 이해하는 데 중요한 지표입니다. 결과는 단일 숫자로 제공해주세요.",
      "context": "신규 사용자가 얼마나 성공적으로 첫 구매를 완료하는지는 제품의 초기 만족도와 가치 전달을 나타내는 핵심 지표입니다. 이를 통해 onboarding 프로세스 개선 및 초기 사용자 획득 전략의 효과를 측정할 수 있습니다.",
      "submission_requirements": "첫 구매를 완료한 고유 사용자 ID의 총 수를 나타내는 단일 값(integer)을 반환합니다.",
      "answer_sql": "WITH first_purchase AS (\n    SELECT\n        user_id,\n        MIN(order_time) AS first_purchase_time\n    FROM\n        pa_orders\n    GROUP BY\n        user_id\n)\nSELECT\n    COUNT(DISTINCT fp.user_id)\nFROM\n    first_purchase fp\nJOIN\n    pa_users pu ON fp.user_id = pu.user_id\nWHERE\n    pu.signup_at <= fp.first_purchase_time;",
      "expected_description": "플랫폼에서 첫 구매를 완료한 고유 사용자의 총 수를 나타냅니다.",
      "expected_columns": [
        "count"
      ],
      "sort_keys": [],
      "hint": "pa_orders 테이블에서 각 user_id 별로 가장 이른 order_time을 찾습니다. 이 사용자들 중에서 pa_users 테이블의 signup_at 보다 첫 구매 시간이 늦은 경우만 집계하여 첫 구매 사용자를 식별합니다. DISTINCT를 사용하여 중복을 제거하고 COUNT 함수로 총 수를 셉니다.",
      "date": "2026-01-01",
      "set_index": 1,
      "xp_value": 3,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_commerce_sql_003_set1",
      "difficulty": "medium",
      "topic": "funnel",
      "requester": "마케팅팀",
      "question": "안녕하세요, 마케팅팀입니다. 최근 한 달간 (2025-12-01 ~ 2025-12-31) 사용자 여정의 주요 단계별 전환율을 분석하고 싶습니다. 특히 'view_product' -> 'add_to_cart' -> 'begin_checkout' -> 'purchase' 로 이어지는 퍼널의 각 단계별 전환율을 알고 싶습니다. 어떤 단계에서 이탈이 가장 많이 발생하는지 파악하여 마케팅 전략 수립에 활용하겠습니다. 결과는 전환율이 높은 순서대로 정렬해주세요.",
      "context": "사용자 행동 흐름을 이해하는 것은 전환율 최적화에 매우 중요합니다. 각 퍼널 단계별 이탈 지점을 파악함으로써, 해당 단계에 대한 개선 방안(예: UI/UX 개선, 프로모션 강화)을 마련할 수 있습니다.",
      "submission_requirements": "각 퍼널 단계별 이벤트 발생 수와 해당 단계의 전환율(이전 단계 대비)을 표시합니다. 결과는 전환율이 높은 순서대로 정렬합니다. 전환율은 소수점 넷째 자리까지 표시합니다.",
      "answer_sql": "WITH funnel_steps AS (\n    SELECT\n        'view_product' AS step,\n        COUNT(DISTINCT user_id) AS users\n    FROM\n        pa_events\n    WHERE\n        event_name = 'view_product'\n        AND event_time >= '2025-12-01 00:00:00'\n        AND event_time < '2026-01-01 00:00:00'\n\n    UNION ALL\n\n    SELECT\n        'add_to_cart' AS step,\n        COUNT(DISTINCT user_id) AS users\n    FROM\n        pa_events\n    WHERE\n        event_name = 'add_to_cart'\n        AND event_time >= '2025-12-01 00:00:00'\n        AND event_time < '2026-01-01 00:00:00'\n\n    UNION ALL\n\n    SELECT\n        'begin_checkout' AS step,\n        COUNT(DISTINCT user_id) AS users\n    FROM\n        pa_events\n    WHERE\n        event_name = 'begin_checkout'\n        AND event_time >= '2025-12-01 00:00:00'\n        AND event_time < '2026-01-01 00:00:00'\n\n    UNION ALL\n\n    SELECT\n        'purchase' AS step,\n        COUNT(DISTINCT user_id) AS users\n    FROM\n        pa_events\n    WHERE\n        event_name = 'purchase'\n        AND event_time >= '2025-12-01 00:00:00'\n        AND event_time < '2026-01-01 00:00:00'\n),\nfunnel_with_previous AS (\n    SELECT\n        step,\n        users,\n        LAG(users, 1, users) OVER (ORDER BY \n            CASE step\n                WHEN 'view_product' THEN 1\n                WHEN 'add_to_cart' THEN 2\n                WHEN 'begin_checkout' THEN 3\n                WHEN 'purchase' THEN 4\n            END\n        ) AS previous_step_users\n    FROM\n        funnel_steps\n)\nSELECT\n    step,\n    users AS step_users,\n    ROUND(CASE\n        WHEN previous_step_users = 0 THEN 0\n        ELSE CAST(users AS NUMERIC) / previous_step_users\n    END, 4) AS conversion_rate\nFROM\n    funnel_with_previous\nORDER BY\n    conversion_rate DESC;",
      "expected_description": "각 퍼널 단계별 사용자 수와 이전 단계 대비 전환율을 보여줍니다.",
      "expected_columns": [
        "step",
        "step_users",
        "conversion_rate"
      ],
      "sort_keys": [
        "conversion_rate"
      ],
      "hint": "각 퍼널 단계별로 distinct user_id 수를 집계합니다. LAG 함수를 사용하여 이전 단계의 사용자 수를 가져온 후, 현재 단계 사용자 수를 이전 단계 사용자 수로 나누어 전환율을 계산합니다. NULLIF 또는 CASE 문으로 division by zero를 방지합니다.",
      "date": "2026-01-01",
      "set_index": 1,
      "xp_value": 5,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_commerce_sql_004_set1",
      "difficulty": "medium",
      "topic": "retention",
      "requester": "CX팀",
      "question": "안녕하세요, CX팀입니다. 장바구니 이탈 현황을 분석하고 싶습니다. 'add_to_cart' 이벤트 후 24시간 이내에 'purchase' 또는 'remove_from_cart' 이벤트가 발생하지 않은 사용자를 장바구니 이탈 고객으로 정의합니다. 최근 한 달간 (2025-12-01 ~ 2025-12-31) 장바구니에 상품을 담았지만 구매하지 않고 이탈한 고객 수를 파악하고 싶습니다. 결과는 고객 ID 별로 정리하여, 어떤 고객이 이탈했는지 명확히 알 수 있도록 해주세요.",
      "context": "장바구니 이탈은 구매 전환의 마지막 단계를 놓치는 상황으로, 고객 경험 개선 및 매출 증대를 위해 반드시 분석해야 합니다. 이탈 고객의 특성을 파악하여 재방문 유도 및 구매 전환율 향상 전략을 수립할 수 있습니다.",
      "submission_requirements": "장바구니 이탈 고객의 user_id와 해당 고객이 상품을 장바구니에 담은 시점(add_to_cart 이벤트 시간)을 반환합니다. 결과는 add_to_cart_time 기준 오름차순 정렬합니다. 이탈 고객 수 합계를 마지막 행에 'TOTAL'이라는 user_id로 별도 표시해주세요.",
      "answer_sql": "WITH AddToCartEvents AS (\n    SELECT\n        user_id,\n        session_id,\n        event_time AS add_to_cart_time\n    FROM\n        pa_events\n    WHERE\n        event_name = 'add_to_cart'\n        AND event_time >= '2025-12-01 00:00:00'\n        AND event_time < '2026-01-01 00:00:00'\n),\n\nPurchaseOrRemoveEvents AS (\n    SELECT\n        user_id,\n        session_id,\n        event_time AS activity_time\n    FROM\n        pa_events\n    WHERE\n        event_name IN ('purchase', 'remove_from_cart')\n        AND event_time >= '2025-12-01 00:00:00'\n        AND event_time < '2026-01-01 00:00:00'\n),\n\nCartAbandonment AS (\n    SELECT\n        ate.user_id,\n        ate.session_id,\n        ate.add_to_cart_time\n    FROM\n        AddToCartEvents ate\n    LEFT JOIN\n        PurchaseOrRemoveEvents pre ON ate.user_id = pre.user_id AND ate.session_id = pre.session_id\n    WHERE\n        pre.activity_time IS NULL OR pre.activity_time > ate.add_to_cart_time + INTERVAL '24 hours'\n)\n\nSELECT user_id, add_to_cart_time FROM CartAbandonment\nUNION ALL\nSELECT 'TOTAL' as user_id, CAST(COUNT(*) AS NUMERIC) FROM CartAbandonment;",
      "expected_description": "장바구니에 상품을 담은 후 24시간 이내에 구매 또는 제거 이벤트가 발생하지 않은 고객의 ID와 해당 이벤트 시간을 보여줍니다. 마지막 행에는 총 이탈 고객 수가 표시됩니다.",
      "expected_columns": [
        "user_id",
        "add_to_cart_time"
      ],
      "sort_keys": [
        "add_to_cart_time"
      ],
      "hint": "먼저 'add_to_cart' 이벤트를 기록한 사용자와 시간을 추출합니다. 다음으로 'purchase' 또는 'remove_from_cart' 이벤트를 기록한 사용자와 시간을 추출합니다. JOIN 시 session_id를 함께 사용하여 동일 세션 내에서의 행동을 비교합니다. LEFT JOIN을 사용하여 add_to_cart 이벤트는 있지만 이후 이벤트가 없는 경우를 찾고, 조건절에서 24시간 이내 구매/제거가 없는 경우를 필터링합니다. UNION ALL을 사용하여 마지막에 총계를 추가합니다.",
      "date": "2026-01-01",
      "set_index": 1,
      "xp_value": 5,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_commerce_sql_005_set1",
      "difficulty": "hard",
      "topic": "revenue",
      "requester": "그로스팀",
      "question": "안녕하세요, 그로스팀입니다. 쿠폰 사용이 매출에 미치는 영향을 분석하고 싶습니다. 'apply_coupon' 이벤트를 발생시킨 사용자들의 구매액(amount)과, 'apply_coupon' 이벤트 없이 'purchase' 이벤트를 발생시킨 사용자들의 구매액을 비교하고 싶습니다. 이를 통해 쿠폰의 실질적인 효과를 측정하고 싶습니다. 분석 기간은 2025년 11월 15일부터 12월 29일까지로 설정합니다. 결과는 쿠폰 사용 여부에 따라 나누어, 각 그룹별 총 매출(GMV)과 평균 주문 금액(AOV)을 보여주세요.",
      "context": "쿠폰 마케팅은 고객 유치 및 구매 전환율 증대에 효과적이지만, 쿠폰 할인으로 인해 실제 매출에 미치는 순영향을 정확히 파악하는 것이 중요합니다. 이를 통해 쿠폰 전략의 ROI를 분석하고 최적화할 수 있습니다.",
      "submission_requirements": "결과는 'coupon_usage' 컬럼 ('Applied Coupon' 또는 'No Coupon')으로 구분하여 표시합니다. 각 그룹별 총 매출(GMV)은 정수, 평균 주문 금액(AOV)은 소수점 둘째 자리까지 반올림하여 표시합니다. 'No Coupon' 그룹은 'apply_coupon' 이벤트가 없는 사용자 중 'purchase' 이벤트를 발생시킨 사용자로 한정합니다.",
      "answer_sql": "WITH CouponAppliedPurchases AS (\n    SELECT\n        po.user_id,\n        po.amount\n    FROM\n        pa_orders po\n    JOIN\n        pa_events pe ON po.user_id = pe.user_id AND DATE(po.order_time) = DATE(pe.event_time)\n    WHERE\n        pe.event_name = 'apply_coupon'\n        AND pe.event_time >= '2025-11-15 00:00:00'\n        AND pe.event_time < '2025-12-30 00:00:00'\n        AND po.order_time >= '2025-11-15 00:00:00'\n        AND po.order_time < '2025-12-30 00:00:00'\n    GROUP BY po.order_id, po.user_id, po.amount -- 각 주문별 쿠폰 적용 여부를 정확히 파악하기 위해 order_id 포함\n),\n\nNoCouponPurchases AS (\n    SELECT\n        po.user_id,\n        po.amount\n    FROM\n        pa_orders po\n    WHERE\n        po.order_time >= '2025-11-15 00:00:00'\n        AND po.order_time < '2025-12-30 00:00:00'\n        AND po.user_id NOT IN (\n            SELECT DISTINCT user_id\n            FROM pa_events\n            WHERE event_name = 'apply_coupon'\n            AND event_time >= '2025-11-15 00:00:00'\n            AND event_time < '2025-12-30 00:00:00'\n        )\n)\n\nSELECT 'Applied Coupon' AS coupon_usage, SUM(amount) AS total_gmv, ROUND(AVG(amount), 2) AS average_aov FROM CouponAppliedPurchases\n\nUNION ALL\n\nSELECT 'No Coupon' AS coupon_usage, SUM(amount) AS total_gmv, ROUND(AVG(amount), 2) AS average_aov FROM NoCouponPurchases;",
      "expected_description": "쿠폰을 적용한 구매 그룹과 쿠폰을 적용하지 않은 구매 그룹으로 나누어, 각 그룹별 총 매출(GMV)과 평균 주문 금액(AOV)을 비교합니다.",
      "expected_columns": [
        "coupon_usage",
        "total_gmv",
        "average_aov"
      ],
      "sort_keys": [
        "coupon_usage"
      ],
      "hint": "쿠폰 적용 사용자 구매와 미적용 사용자 구매를 별도의 CTE(Common Table Expression)로 분리합니다. 'apply_coupon' 이벤트와 'purchase' 이벤트의 시간적 연관성을 고려해야 하며, 같은 날짜에 발생한 주문만을 대상으로 합니다. 'No Coupon' 그룹은 'apply_coupon' 이벤트 기록이 없는 사용자 중 구매를 한 경우로 정의합니다. 각 그룹별로 SUM과 AVG 함수를 적용하고 UNION ALL로 결과를 합칩니다.",
      "date": "2026-01-01",
      "set_index": 1,
      "xp_value": 8,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_commerce_sql_006_set1",
      "difficulty": "hard",
      "topic": "retention",
      "requester": "SCM팀",
      "question": "안녕하세요, SCM팀입니다. 재구매율이 높은 사용자 그룹을 파악하고 싶습니다. 'purchase' 이벤트를 두 번 이상 발생시킨 사용자들을 '재구매 고객'으로 정의합니다. 2025년 11월 1일부터 12월 29일까지의 기간 동안, 첫 구매 이후 최소 한 번 이상 재구매한 사용자들의 ID와 각 사용자의 재구매 횟수를 파악하여, 우수 고객 그룹의 특성을 분석하는 데 활용하겠습니다. 결과는 재구매 횟수가 많은 순서대로 정렬해주세요.",
      "context": "고객 유지율 증가는 장기적인 비즈니스 성장에 필수적입니다. 재구매 고객은 일반적으로 신규 고객보다 LTV(Lifetime Value)가 높기 때문에, 이들을 식별하고 이탈을 방지하는 것은 SCM 및 마케팅 전략의 중요한 목표입니다.",
      "submission_requirements": "재구매 고객의 user_id와 해당 고객의 총 재구매 횟수를 반환합니다. 결과는 재구매 횟수(reorder_count) 기준 내림차순으로 정렬합니다. 재구매 횟수가 0인 사용자는 결과에 포함하지 않습니다.",
      "answer_sql": "WITH CustomerPurchases AS (\n    SELECT\n        user_id,\n        order_time,\n        ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY order_time) as purchase_rank\n    FROM\n        pa_orders\n    WHERE\n        order_time >= '2025-11-01 00:00:00'\n        AND order_time < '2025-12-30 00:00:00'\n)\nSELECT\n    user_id,\n    COUNT(user_id) - 1 AS reorder_count\nFROM\n    CustomerPurchases\nWHERE\n    purchase_rank > 1\nGROUP BY\n    user_id\nORDER BY\n    reorder_count DESC;",
      "expected_description": "첫 구매 이후 두 번째 구매부터의 횟수를 기준으로 재구매 고객을 분류하고, 각 고객의 재구매 횟수를 내림차순으로 정렬하여 보여줍니다.",
      "expected_columns": [
        "user_id",
        "reorder_count"
      ],
      "sort_keys": [
        "reorder_count"
      ],
      "hint": "pa_orders 테이블에서 각 user_id 별로 order_time을 기준으로 순위를 매깁니다 (ROW_NUMBER 함수 사용). 첫 번째 구매 (purchase_rank = 1) 이후의 구매들만 집계하여 재구매 횟수를 계산합니다. GROUP BY user_id를 사용하여 각 사용자의 재구매 횟수를 집계하고, reorder_count가 0보다 큰 경우만 필터링하여 결과를 정렬합니다.",
      "date": "2026-01-01",
      "set_index": 1,
      "xp_value": 8,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_ecommerce_sql_001_set2",
      "difficulty": "easy",
      "topic": "revenue",
      "requester": "경영진",
      "question": "안녕하세요, 경영진입니다. 최근 1개월 간 일별 GMV(Gross Merchandise Value) 추이를 파악하고 싶습니다. 특히, 매출 발생액이 높은 순서대로 상위 5일을 보고해주시면 감사하겠습니다. 결과는 날짜별 총 매출액을 기준으로 내림차순 정렬해주세요.",
      "context": "회사의 전반적인 매출 성과를 파악하고, 특정 기간 동안의 매출 변동 추이를 이해하기 위함입니다. 이를 통해 향후 프로모션 계획 수립 및 비즈니스 전략 결정에 활용하고자 합니다.",
      "submission_requirements": "결과는 date 컬럼과 daily_gmv 컬럼으로 구성되며, daily_gmv 컬럼은 소수점 둘째 자리까지 반올림하여 표시합니다. 결과는 daily_gmv 기준 내림차순으로 정렬하고, 상위 5개의 데이터만 보여줍니다.",
      "answer_sql": "SELECT\n    DATE(order_time) AS date,\n    ROUND(SUM(amount), 2) AS daily_gmv\nFROM\n    pa_orders\nWHERE\n    order_time >= '2025-11-29' AND order_time < '2025-12-30' -- 지난 1개월 (2025-11-29 ~ 2025-12-29)\nGROUP BY\n    date\nORDER BY\n    daily_gmv DESC\nLIMIT 5;",
      "expected_description": "지정된 기간 동안 일별 총 매출액 (GMV)을 나타내는 테이블입니다. 각 행은 특정 날짜와 해당 날짜의 총 매출액을 포함합니다.",
      "expected_columns": [
        "date",
        "daily_gmv"
      ],
      "sort_keys": [
        "daily_gmv"
      ],
      "hint": "pa_orders 테이블의 order_time 컬럼에서 날짜 정보만 추출하고, amount 컬럼의 합계를 계산하여 일별 총 매출액을 구합니다. 날짜 범위는 2025년 11월 29일부터 2025년 12월 29일까지로 설정하고, 가장 높은 매출을 보인 상위 5일을 보여주기 위해 ORDER BY DESC 및 LIMIT 구문을 사용합니다.",
      "date": "2026-01-01",
      "set_index": 2,
      "xp_value": 3,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_ecommerce_sql_002_set2",
      "difficulty": "easy",
      "topic": "activation",
      "requester": "PM팀",
      "question": "안녕하세요, PM팀입니다. 2025년 12월 기준으로 첫 구매(purchase 이벤트 발생)를 완료한 신규 고객 수를 파악하고 싶습니다. 첫 구매일은 user_id별로 가장 먼저 발생하는 purchase 이벤트의 시간으로 정의합니다. 결과는 전체 신규 고객 수만 표시해주시면 됩니다.",
      "context": "신규 고객의 활성화 상태를 파악하고, 온보딩 프로세스의 효과를 측정하기 위함입니다. 이를 통해 향후 신규 고객 확보 전략 및 캠페인 최적화에 기여하고자 합니다.",
      "submission_requirements": "결과는 'new_customer_count'라는 단일 컬럼으로 표시되며, 정수형 값입니다.",
      "answer_sql": "WITH first_purchase AS (\n    SELECT\n        user_id,\n        MIN(event_time) AS first_purchase_time\n    FROM\n        pa_events\n    WHERE\n        event_name = 'purchase'\n    GROUP BY\n        user_id\n)\nSELECT\n    COUNT(fp.user_id) AS new_customer_count\nFROM\n    first_purchase fp\nJOIN\n    pa_users u ON fp.user_id = u.user_id\nWHERE\n    fp.first_purchase_time >= '2025-12-01' AND fp.first_purchase_time < '2026-01-01';",
      "expected_description": "2025년 12월 기준으로 첫 구매를 완료한 신규 고객 수를 나타내는 단일 값입니다. 'new_customer_count'라는 컬럼명으로 표시됩니다.",
      "expected_columns": [
        "new_customer_count"
      ],
      "sort_keys": [],
      "hint": "먼저, pa_events 테이블에서 'purchase' 이벤트만 필터링하여 각 user_id별 최초 구매 시간을 계산하는 CTE(Common Table Expression)를 생성합니다. 그 후, 이 CTE와 pa_users 테이블을 조인하고, 최초 구매 시간이 2025년 12월 내에 속하는 사용자 수를 세어 첫 구매 고객 수를 산출합니다.",
      "date": "2026-01-01",
      "set_index": 2,
      "xp_value": 3,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_ecommerce_sql_003_set2",
      "difficulty": "medium",
      "topic": "funnel",
      "requester": "그로스팀",
      "question": "그로스팀입니다. 'view_product' 이벤트 이후 'add_to_cart' 이벤트로 전환하는 고객들의 전환율을 계산하고 싶습니다. 분석 기간은 2025년 11월 1일부터 2025년 11월 30일까지로 설정해주세요. 전환율은 (add_to_cart 이벤트 발생 사용자 수 / view_product 이벤트 발생 사용자 수) * 100 으로 계산하며, 소수점 둘째 자리까지 표시해주세요. 결과는 'view_to_cart_conversion_rate'라는 컬럼명으로 표시합니다.",
      "context": "상품 상세 페이지가 장바구니 담기로 얼마나 잘 이어지는지 파악하여, 상품 페이지의 매력도나 정보 전달의 효과를 측정하고 싶습니다. 이를 통해 상품 상세 페이지 개선 방향을 도출하고자 합니다.",
      "submission_requirements": "결과는 'view_to_cart_conversion_rate'라는 단일 컬럼으로 표시되며, 소수점 둘째 자리까지 반올림된 실수형 값입니다. 결과는 오름차순 또는 내림차순 정렬이 필요하지 않습니다.",
      "answer_sql": "WITH event_counts AS (\n    SELECT\n        SUM(CASE WHEN event_name = 'view_product' THEN 1 ELSE 0 END) AS view_product_users,\n        SUM(CASE WHEN event_name = 'add_to_cart' THEN 1 ELSE 0 END) AS add_to_cart_users\n    FROM\n        pa_events\n    WHERE\n        event_time BETWEEN '2025-11-01 00:00:00' AND '2025-11-30 23:59:59'\n)\nSELECT\n    ROUND(NULLIF(ec.add_to_cart_users, 0) * 100.0 / NULLIF(ec.view_product_users, 0), 2) AS view_to_cart_conversion_rate\nFROM\n    event_counts ec;",
      "expected_description": "2025년 11월 한 달 동안 'view_product' 이벤트 발생 사용자 대비 'add_to_cart' 이벤트 발생 사용자의 비율을 나타내는 전환율입니다. 'view_to_cart_conversion_rate'라는 컬럼명으로 표시됩니다.",
      "expected_columns": [
        "view_to_cart_conversion_rate"
      ],
      "sort_keys": [],
      "hint": "pa_events 테이블에서 'view_product'와 'add_to_cart' 이벤트를 카운트하는 CTE를 만듭니다. 이 CTE를 사용하여 전환율을 계산할 때, 0으로 나누는 오류를 방지하기 위해 NULLIF 함수를 사용합니다. 전환율은 100을 곱하여 백분율로 표시하고, 소수점 둘째 자리까지 반올림합니다.",
      "date": "2026-01-01",
      "set_index": 2,
      "xp_value": 5,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_ecommerce_sql_004_set2",
      "difficulty": "medium",
      "topic": "retention",
      "requester": "CX팀",
      "question": "CX팀입니다. 장바구니에 상품을 담았지만 최종 구매(purchase)로 이어지지 않은 고객들의 세션을 분석하고 싶습니다. 'add_to_cart' 이벤트는 발생했지만 'purchase' 이벤트가 발생하지 않은 세션 ID와 해당 세션의 총 이벤트 수를 파악하고 싶습니다. 분석 기간은 2025년 12월 1일부터 2025년 12월 15일까지로 해주세요. 결과는 세션 ID 기준으로 오름차순 정렬해주세요.",
      "context": "장바구니 단계에서의 고객 이탈 원인을 파악하고, 이를 개선하기 위한 전략을 수립하는 데 활용하고자 합니다. 어떤 세션에서 이탈이 많이 발생하는지, 그리고 해당 세션에서는 어떤 행동이 주로 나타나는지 파악하는 것이 중요합니다.",
      "submission_requirements": "결과는 session_id와 total_events 컬럼으로 구성됩니다. total_events는 해당 세션 내의 총 이벤트 수를 나타내며, 정수형입니다. 결과는 session_id 컬럼 기준 오름차순으로 정렬됩니다.",
      "answer_sql": "WITH cart_added_sessions AS (\n    SELECT DISTINCT\n        session_id\n    FROM\n        pa_events\n    WHERE\n        event_name = 'add_to_cart'\n        AND event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-15 23:59:59'\n),\nnot_purchased_sessions AS (\n    SELECT DISTINCT\n        session_id\n    FROM\n        pa_events\n    WHERE\n        event_name = 'purchase'\n        AND event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-15 23:59:59'\n),\nsessions_with_event_count AS (\n    SELECT\n        session_id,\n        COUNT(event_id) AS total_events\n    FROM\n        pa_events\n    WHERE\n        event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-15 23:59:59'\n    GROUP BY\n        session_id\n)\nSELECT\n    sac.session_id,\n    sec.total_events\nFROM\n    cart_added_sessions sac\nLEFT JOIN\n    not_purchased_sessions nps ON sac.session_id = nps.session_id\nJOIN\n    sessions_with_event_count sec ON sac.session_id = sec.session_id\nWHERE\n    nps.session_id IS NULL\nORDER BY\n    sac.session_id ASC;",
      "expected_description": "2025년 12월 1일부터 15일까지 'add_to_cart' 이벤트는 발생했지만 'purchase' 이벤트는 발생하지 않은 세션의 ID와 해당 세션 내 총 이벤트 수를 보여주는 테이블입니다. 'session_id'와 'total_events' 컬럼으로 구성됩니다.",
      "expected_columns": [
        "session_id",
        "total_events"
      ],
      "sort_keys": [
        "session_id"
      ],
      "hint": "먼저 'add_to_cart'가 발생한 세션과 'purchase'가 발생하지 않은 세션을 각각 CTE로 분리합니다. 이후, 'add_to_cart'는 발생했지만 'purchase'는 발생하지 않은 세션만 추출하기 위해 LEFT JOIN과 WHERE IS NULL 구문을 사용합니다. 마지막으로, 추출된 세션들의 총 이벤트 수를 계산하여 결과를 조합합니다.",
      "date": "2026-01-01",
      "set_index": 2,
      "xp_value": 5,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_ecommerce_sql_005_set2",
      "difficulty": "hard",
      "topic": "retention",
      "requester": "마케팅팀",
      "question": "마케팅팀입니다. 2025년 12월에 첫 구매를 한 사용자 그룹(cohort)의 1개월 후 재구매율을 분석하고 싶습니다. 즉, 2025년 12월에 첫 구매를 완료한 사용자들이 다음 달(2026년 1월)에 다시 구매를 하는 비율을 알고 싶습니다. 첫 구매일은 pa_orders 테이블의 order_time을 기준으로 판단합니다. 재구매율은 (2026년 1월에 재구매한 사용자 수 / 2025년 12월 첫 구매자 수) * 100으로 계산해주세요. 결과는 'retention_rate_1m' 컬럼으로 표시하며, 소수점 둘째 자리까지 반올림합니다.",
      "context": "신규 고객 확보 후 얼마나 효과적으로 고객을 유지하고 재구매를 유도하는지 파악하여, 고객 생애 가치(CLTV) 증대를 위한 마케팅 전략 수립의 기초 자료로 활용하고자 합니다.",
      "submission_requirements": "결과는 'retention_rate_1m'이라는 단일 컬럼으로 표시되며, 소수점 둘째 자리까지 반올림된 실수형 값입니다. 결과는 정렬이 필요하지 않습니다.",
      "answer_sql": "WITH first_purchase_users AS (\n    SELECT\n        user_id,\n        MIN(order_time) AS first_order_time\n    FROM\n        pa_orders\n    WHERE\n        order_time >= '2025-12-01 00:00:00' AND order_time < '2026-01-01 00:00:00'\n    GROUP BY\n        user_id\n),\nsubsequent_purchases AS (\n    SELECT DISTINCT\n        o.user_id\n    FROM\n        pa_orders o\n    JOIN\n        first_purchase_users fpu ON o.user_id = fpu.user_id\n    WHERE\n        o.order_time >= '2026-01-01 00:00:00' AND o.order_time < '2026-02-01 00:00:00'\n)\nSELECT\n    ROUND(CAST(COUNT(sp.user_id) AS NUMERIC) * 100.0 / COUNT(fpu.user_id), 2) AS retention_rate_1m\nFROM\n    first_purchase_users fpu\nLEFT JOIN\n    subsequent_purchases sp ON fpu.user_id = sp.user_id;",
      "expected_description": "2025년 12월에 첫 구매를 한 사용자 그룹의 1개월 후 재구매율을 나타냅니다. 'retention_rate_1m'이라는 컬럼명으로 표시되며, 백분율로 표현됩니다.",
      "expected_columns": [
        "retention_rate_1m"
      ],
      "sort_keys": [],
      "hint": "첫 번째 CTE에서는 pa_orders 테이블을 사용하여 2025년 12월에 첫 구매를 한 사용자들의 user_id와 첫 구매 시간을 추출합니다. 두 번째 CTE에서는 이 첫 구매자들 중에서 2026년 1월에 다시 구매한 사용자들의 user_id를 추출합니다. 마지막으로, 첫 구매자 수를 분모로, 1개월 후 재구매자 수를 분자로 하여 재구매율을 계산하고 소수점 둘째 자리까지 반올림합니다. COUNT 함수 사용 시, 분모가 0이 되는 경우를 방지하기 위해 LEFT JOIN과 COUNT(sp.user_id)를 활용합니다.",
      "date": "2026-01-01",
      "set_index": 2,
      "xp_value": 8,
      "expected_result": [],
      "expected_row_count": 0
    },
    {
      "problem_id": "2026-01-01_ecommerce_sql_006_set2",
      "difficulty": "hard",
      "topic": "funnel",
      "requester": "그로스팀",
      "question": "그로스팀입니다. 'apply_coupon' 이벤트 발생 후 'purchase' 이벤트까지 성공적으로 이어진 고객들의 평균 쿠폰 사용액을 분석하고 싶습니다. 또한, 쿠폰 적용 없이 구매한 고객들의 평균 구매 금액과 비교하여 쿠폰의 효과를 정량적으로 평가하고 싶습니다. 분석 기간은 2025년 12월 1일부터 2025년 12월 31일까지입니다. 결과는 'coupon_applied_avg_amount'와 'no_coupon_avg_amount' 두 컬럼으로 보여주세요.",
      "context": "쿠폰 프로모션의 실제 효과를 파악하고, 쿠폰이 고객의 구매 결정에 미치는 영향을 분석하여 향후 쿠폰 발행 전략 수립에 활용하고자 합니다. 쿠폰 사용 그룹과 미사용 그룹의 평균 구매 금액을 비교 분석하는 것이 중요합니다.",
      "submission_requirements": "결과는 'coupon_applied_avg_amount'와 'no_coupon_avg_amount' 두 컬럼으로 구성되며, 모두 소수점 둘째 자리까지 반올림된 실수형 값입니다. 결과는 정렬이 필요하지 않습니다.",
      "answer_sql": "WITH coupon_purchase AS (\n    SELECT\n        o.user_id,\n        o.amount\n    FROM\n        pa_orders o\n    JOIN (\n        SELECT DISTINCT\n            user_id\n        FROM\n            pa_events\n        WHERE\n            event_name = 'apply_coupon'\n            AND event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n    ) AS cp_users ON o.user_id = cp_users.user_id\n    WHERE\n        o.order_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n),\nno_coupon_purchase AS (\n    SELECT\n        o.user_id,\n        o.amount\n    FROM\n        pa_orders o\n    WHERE\n        o.user_id NOT IN (\n            SELECT DISTINCT user_id FROM pa_events WHERE event_name = 'apply_coupon' AND event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n        )\n        AND o.order_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n)\nSELECT\n    ROUND(COALESCE(AVG(cp.amount), 0), 2) AS coupon_applied_avg_amount,\n    ROUND(COALESCE(AVG(ncp.amount), 0), 2) AS no_coupon_avg_amount\nFROM\n    coupon_purchase cp\nFULL OUTER JOIN\n    no_coupon_purchase ncp ON cp.user_id = ncp.user_id;",
      "expected_description": "2025년 12월 한 달 동안 쿠폰을 적용하여 구매한 고객들의 평균 구매 금액과 쿠폰을 적용하지 않고 구매한 고객들의 평균 구매 금액을 비교하는 테이블입니다. 'coupon_applied_avg_amount'와 'no_coupon_avg_amount' 두 컬럼으로 구성됩니다.",
      "expected_columns": [
        "coupon_applied_avg_amount",
        "no_coupon_avg_amount"
      ],
      "sort_keys": [],
      "hint": "두 개의 CTE를 생성합니다. 첫 번째 CTE ('coupon_purchase')는 'apply_coupon' 이벤트가 발생한 사용자의 구매 기록을 추출합니다. 두 번째 CTE ('no_coupon_purchase')는 'apply_coupon' 이벤트가 발생하지 않은 사용자의 구매 기록을 추출합니다. 마지막으로, 두 CTE를 FULL OUTER JOIN하여 쿠폰 적용 그룹과 미적용 그룹의 평균 구매 금액을 계산하고, COALESCE 함수를 사용하여 NULL 값을 0으로 처리합니다.",
      "date": "2026-01-01",
      "set_index": 2,
      "xp_value": 8,
      "expected_result": [],
      "expected_row_count": 0
    }
  ]
}